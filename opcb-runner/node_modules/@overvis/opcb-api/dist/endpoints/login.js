"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.SCHEMA = void 0;
const tslib_1 = require("tslib");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const server_tools_1 = require("@overvis/server-tools");
const typebox_1 = require("@sinclair/typebox");
const crypto = tslib_1.__importStar(require("crypto"));
const BODY_SCHEMA = typebox_1.Type.Object({
    username: typebox_1.Type.String({ maxLength: 30 }),
    password: typebox_1.Type.String({ maxLength: 30 }),
}, { additionalProperties: false });
const OK_RESPONSE_SCHEMA = typebox_1.Type.Object({
    token: typebox_1.Type.String({ minLength: 36, maxLength: 36 }),
    access: typebox_1.Type.Object({
        configuration: typebox_1.Type.Union([
            typebox_1.Type.Literal("none"),
            typebox_1.Type.Literal("read"),
            typebox_1.Type.Literal("readWrite"),
        ]),
        modbusDevices: typebox_1.Type.Union([
            typebox_1.Type.Literal("none"),
            typebox_1.Type.Literal("read"),
            typebox_1.Type.Literal("readWrite"),
        ]),
    }),
    ttl: typebox_1.Type.Integer({ minimum: 0 }),
});
exports.SCHEMA = {
    body: BODY_SCHEMA,
    response: (0, server_tools_1.apiResponse)(OK_RESPONSE_SCHEMA),
};
async function handler(req) {
    const confs = (await this.bus.getConfs([`auth:users:*`, `auth:sessionTtl`]));
    const ttl = parseInt(confs["auth:sessionTtl"] || "300");
    const users = {};
    for (let i = 0; i < 100; i++) {
        const username = confs[`auth:users:${i}:username`];
        if (!username) {
            break;
        }
        const encryptedPassword = confs[`auth:users:${i}:encryptedPassword`];
        if (!encryptedPassword) {
            continue;
        }
        const allowAuthThroughApi = confs[`auth:users:${i}:allowAuthThroughApi`];
        if (!allowAuthThroughApi) {
            continue;
        }
        const configurationAccess = confs[`auth:users:${i}:configurationAccess`];
        if (!configurationAccess) {
            continue;
        }
        const modbusDevicesAccess = confs[`auth:users:${i}:modbusDevicesAccess`];
        if (!modbusDevicesAccess) {
            continue;
        }
        users[username] = {
            encryptedPassword,
            access: {
                configuration: configurationAccess,
                modbusDevices: modbusDevicesAccess,
            },
        };
    }
    const user = users[req.body.username];
    if (!(user === null || user === void 0 ? void 0 : user.encryptedPassword)) {
        throw new server_tools_1.ApiUserError(401, "InvalidUserOrPassword", "Invalid username or password");
    }
    if (!(0, opcb_ts_shared_1.checkIfPasswordIsCorrect)(req.body.password, user.encryptedPassword)) {
        throw new server_tools_1.ApiUserError(401, "InvalidUserOrPassword", "Invalid username or password");
    }
    const token = crypto.randomUUID();
    this.sessions[token] = {
        username: req.body.username,
        access: user.access,
        expiresOn: Date.now() + ttl * 1000,
        ttl,
    };
    await this.bus.createSession(`api-${token}`);
    return { token, access: user.access, ttl };
}
exports.handler = handler;
//# sourceMappingURL=login.js.map