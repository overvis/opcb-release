"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.SCHEMA = exports.PARAMS_SCHEMA = void 0;
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const server_tools_1 = require("@overvis/server-tools");
const typebox_1 = require("@sinclair/typebox");
const auth_1 = require("../auth");
exports.PARAMS_SCHEMA = typebox_1.Type.Object({
    id: typebox_1.Type.String({ format: "uuid" }),
});
const OK_RESPONSE_SCHEMA = typebox_1.Type.Array(typebox_1.Type.Object({
    id: typebox_1.Type.String({ format: "uuid" }),
    startedOn: typebox_1.Type.String({ format: "date-time" }),
    finishedOn: typebox_1.Type.Optional(typebox_1.Type.String({ format: "date-time" })),
    error: typebox_1.Type.Optional(typebox_1.Type.String()),
    log: typebox_1.Type.Optional(typebox_1.Type.String()),
}));
exports.SCHEMA = {
    params: exports.PARAMS_SCHEMA,
    response: (0, server_tools_1.apiResponse)(OK_RESPONSE_SCHEMA),
};
function openHandler(req) {
    const records = this.memdb
        .prepare("select * from task_runs where task_id = @taskId;")
        .all({ taskId: req.params.id }).map(opcb_ts_shared_1.nullToUndefined);
    return records.map(({ id, started_on: startedOn, finished_on: finishedOn, error, run_log: log }) => ({
        id,
        startedOn: (0, server_tools_1.dateToIsoString)(new Date(startedOn * 1000)),
        finishedOn: finishedOn ? (0, server_tools_1.dateToIsoString)(new Date(finishedOn * 1000)) : undefined,
        error,
        log,
    }));
}
exports.handler = (0, auth_1.auth)("readConfs", openHandler);
//# sourceMappingURL=task-get-runs.js.map