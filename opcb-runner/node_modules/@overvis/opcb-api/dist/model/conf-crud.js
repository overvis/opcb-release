"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simpleKeyed = exports.update = exports.createConfCrud = void 0;
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
function createConfCrud(prefix, keyFields, toListItem, fromCreateItem, fromUpdateItem, addNullKeysOnRemove = []) {
    return {
        list: async (bus) => list(bus, prefix, toListItem),
        create: async (bus, item) => create(bus, keyFields, prefix, fromCreateItem(item)),
        update: async (bus, key, item) => update(bus, prefix, key, fromUpdateItem(item)),
        remove: async (bus, key) => remove(bus, prefix, key, addNullKeysOnRemove),
    };
}
exports.createConfCrud = createConfCrud;
async function getRecords(bus, prefix) {
    return bus.getConfs([`${prefix}:*`]);
}
function groupRecsByIdx(recs, prefix) {
    const res = [];
    for (const key in recs) {
        const parts = key.slice(prefix.length + 1).split(":");
        const idx = parseInt(parts[0]);
        const inkey = parts.slice(1).join(":");
        if (!res[idx]) {
            res[idx] = {};
        }
        res[idx][inkey] = recs[key];
    }
    return res;
}
async function list(bus, prefix, toListItem) {
    const recs = await getRecords(bus, prefix);
    const groupedRecs = groupRecsByIdx(recs, prefix);
    return groupedRecs.map(toListItem);
}
function compareKey(rec, key, prefix) {
    if (!prefix) {
        prefix = "";
    }
    else {
        prefix = `${prefix}:`;
    }
    for (const keyField in key) {
        if (rec[`${prefix}${keyField}`] !== key[keyField]) {
            return false;
        }
    }
    return true;
}
function keyIsEmpty(rec, keyFields, prefix) {
    for (const keyField of keyFields) {
        if (rec[`${prefix}:${keyField}`]) {
            return false;
        }
    }
    return true;
}
async function getNewIdx(bus, prefix, key) {
    const recs = await getRecords(bus, prefix);
    let i = 0;
    for (i = 0; i < 99; i++) {
        if (keyIsEmpty(recs, Object.keys(key), `${prefix}:${i}`)) {
            return i;
        }
        if (compareKey(recs, key, `${prefix}:${i}`)) {
            return "exists";
        }
    }
    return i;
}
function addPrefix(prefix, item) {
    for (const key in item) {
        item[`${prefix}:${key}`] = item[key];
        delete item[key];
    }
}
async function create(bus, keyFields, prefix, item) {
    const key = composeKey(keyFields, item);
    const i = await getNewIdx(bus, prefix, key);
    if (i === "exists") {
        return "exists";
    }
    addPrefix(`${prefix}:${i}`, item);
    return bus.sendRequest(new opcb_ts_shared_1.redisCmd.SetConfig(item));
}
function composeKey(keyFields, item) {
    return keyFields.reduce((acc, keyField) => {
        const v = item[keyField];
        acc[keyField] = v === null ? undefined : v;
        return acc;
    }, {});
}
async function findIdx(bus, prefix, key) {
    const recs = await getRecords(bus, prefix);
    let i = 0;
    for (i = 0; i < 99; i++) {
        if (compareKey(recs, key, `${prefix}:${i}`)) {
            return i;
        }
    }
    return undefined;
}
async function update(bus, prefix, key, item) {
    const i = await findIdx(bus, prefix, key);
    if (i === undefined) {
        return "notfound";
    }
    addPrefix(`${prefix}:${i}`, item);
    return bus.sendRequest(new opcb_ts_shared_1.redisCmd.SetConfig(item));
}
exports.update = update;
async function remove(bus, prefix, key, addNullKeys) {
    const recs = await getRecords(bus, prefix);
    const groupedRecs = groupRecsByIdx(recs, prefix);
    // generating final records to be saved
    const changes = { [`${prefix}:*`]: null };
    let found = false;
    let idx = 0;
    for (const rec of groupedRecs) {
        if (compareKey(rec, key)) {
            found = true;
            continue;
        }
        for (const nullKey of addNullKeys) {
            changes[`${prefix}:${idx}:${nullKey}`] = null;
        }
        for (const key in rec) {
            const v = rec[key];
            changes[`${prefix}:${idx}:${key}`] = v !== undefined ? v : null;
        }
        idx++;
    }
    if (!found) {
        return "notfound";
    }
    return bus.sendRequest(new opcb_ts_shared_1.redisCmd.SetConfig(changes));
}
function simpleKeyed(pk, crud) {
    return {
        list: crud.list,
        create: crud.create,
        update: async (bus, key, item) => crud.update(bus, { [pk]: key }, item),
        remove: async (bus, key) => crud.remove(bus, { [pk]: key }),
    };
}
exports.simpleKeyed = simpleKeyed;
//# sourceMappingURL=conf-crud.js.map