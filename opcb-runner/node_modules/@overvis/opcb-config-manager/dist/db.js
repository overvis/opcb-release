"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateDb = void 0;
const tslib_1 = require("tslib");
const _1 = require(".");
const fs = tslib_1.__importStar(require("fs"));
const crypto = tslib_1.__importStar(require("crypto"));
function migrateDb(db, dbMigrationsDir) {
    // check if migrations table exists
    const res1 = db
        .prepare(`select count(*) as "count" from sqlite_master where type='table' and name='applied_migrations';`)
        .get();
    if (!(res1 === null || res1 === void 0 ? void 0 : res1.count)) {
        migrateFrom(db, dbMigrationsDir, undefined);
        return;
    }
    const res = db
        .prepare(`select id, file_name, file_hash from applied_migrations order by id;`)
        .all();
    let lastId;
    const appliedMigrations = {};
    for (const r of res) {
        appliedMigrations[r.id] = { filename: r.file_name, hash: r.file_hash };
        if (lastId === undefined || r.id > lastId) {
            lastId = r.id;
        }
    }
    // check applied migrations
    const [migrations] = getMigrations(dbMigrationsDir);
    if (lastId !== undefined) {
        for (let i = 0; i <= lastId; i++) {
            const applied = appliedMigrations[i];
            const migration = migrations[i];
            if (!migration) {
                _1.logger.error(`Missing migration #${i}. Aborting migration process.`);
                return;
            }
            if (!applied) {
                _1.logger.error(`Gap in applied migrations, missing (${migration.filename}). ` +
                    `Aborting migration process.`);
                return;
            }
            if (applied.filename !== migration.filename) {
                _1.logger.error(`Incorrect applied migration name ` +
                    `("${applied.filename}" should be "${migration.filename}"). ` +
                    `Aborting migration process.`);
                return;
            }
            if (applied.hash !== migration.hash) {
                _1.logger.error(`Incorrect applied migration hash ` +
                    `("${applied.filename}" hash should be "${migration.hash}"). ` +
                    `Aborting migration process.`);
                return;
            }
        }
    }
    if (lastId === undefined) {
        migrateFrom(db, dbMigrationsDir, undefined);
        return;
    }
    migrateFrom(db, dbMigrationsDir, lastId);
}
exports.migrateDb = migrateDb;
function getMigrations(dbMigrationsDir) {
    const migrationFiles = fs.readdirSync(dbMigrationsDir).filter((f) => !f.startsWith("."));
    const migrations = [];
    let latestId;
    for (const filename of migrationFiles) {
        const [idStr, name, type, ext] = filename.split(".");
        const id = Number(idStr);
        if (type !== "up" || ext !== "sql")
            continue;
        const sql = fs.readFileSync(dbMigrationsDir + "/" + filename, "utf8");
        const hash = crypto.createHash("sha256").update(sql).digest("hex");
        migrations[id] = {
            id,
            name,
            filename,
            sql,
            hash,
        };
        if (latestId === undefined || latestId < Number(id)) {
            latestId = Number(id);
        }
    }
    return [migrations, latestId];
}
function migrateFrom(db, dbMigrationsDir, fromId) {
    const [migrations, latestId] = getMigrations(dbMigrationsDir);
    if (latestId === undefined || (fromId !== undefined && fromId >= latestId))
        return;
    _1.logger.warn(`Mirgating database from ${fromId || "clean state"} to ${latestId}...`);
    const startId = fromId === undefined ? 0 : fromId + 1;
    for (let i = startId; i <= latestId; i++) {
        applyMigration(db, migrations[i]);
    }
}
function applyMigration(db, migration) {
    _1.logger.info(`Applying migration ${migration.filename}...`);
    db.transaction(() => {
        db.exec(migration.sql);
        db.prepare(`insert into applied_migrations (id, file_name, file_hash) values (?, ?, ?);`).run(migration.id, migration.filename, migration.hash);
    })();
}
//# sourceMappingURL=db.js.map