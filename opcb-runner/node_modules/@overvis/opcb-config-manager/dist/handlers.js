"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSetConfigHandler = exports.createResetConfigHandler = void 0;
const tslib_1 = require("tslib");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const fs = tslib_1.__importStar(require("fs"));
const _1 = require(".");
const encrypt_1 = require("./encrypt");
const logic_1 = require("./logic");
const manufacturer_1 = require("./manufacturer");
const static_1 = require("./static");
const utils_1 = require("./utils");
const validate_1 = require("./validate");
const write_1 = require("./write");
function createResetConfigHandler(bus, state, factoryConfigFile, configFile, manufacturerFile) {
    return async () => {
        _1.logger.debug("Received config reset request.");
        // take factory config as the default
        let configJson;
        if ("path" in factoryConfigFile) {
            _1.logger.info(`Reading factory config from ${factoryConfigFile.path}`);
            configJson = (await (0, utils_1.loadConfigFile)(factoryConfigFile.path));
        }
        else {
            _1.logger.info(`Reading factory config from provided string.`);
            configJson = JSON.parse(factoryConfigFile.contents);
        }
        // apply default values from the schema on top
        (0, logic_1.applyDefaultConfigValues)(configJson, opcb_ts_shared_1.CONFIG_SCHEMA);
        const config = configJson;
        await (0, encrypt_1.encryptPasswordsInConfigFile)(config);
        // write config to file
        await (0, write_1.saveConfigToFile)(config, configFile);
        // update config and routing in redis
        state.config = config;
        await bus.setConfs((0, logic_1.flattenConfig)(config));
        // read manufacturer file
        const manufacturer = await (0, manufacturer_1.readManufacturerLicenseFile)(manufacturerFile);
        // set state
        const stateChange = (0, static_1.getStaticInfo)(manufacturer);
        // calculate and set routing
        const routes = (0, logic_1.calculateRouting)(state.config);
        await bus.setState(Object.assign(stateChange, routes, {
            boundToOcpServer: state.config.overvisVpn.boundToOcpServer,
        }));
        // run sync
        await bus.sendMsg(new opcb_ts_shared_1.redisBus.SyncConfig());
        await bus.sendMsg(new opcb_ts_shared_1.redisBus.SyncRouting());
        return new opcb_ts_shared_1.redisBus.Done();
    };
}
exports.createResetConfigHandler = createResetConfigHandler;
function createSetConfigHandler(bus, state, validate, configFile, factoryConfigFile) {
    return async (cmd) => {
        if (!cmd.validateOnly) {
            _1.logger.debug("Received config change request.");
        }
        else {
            _1.logger.debug("Received config validation request.");
        }
        // clone config from state
        const config = JSON.parse(JSON.stringify(state.config));
        // validate
        let changes = Object.assign({}, cmd.values);
        const validationResult = (0, validate_1.validateConfigChanges)(config, changes, validate);
        if (cmd.validateOnly) {
            return validationResult;
        }
        if (validationResult.status !== "ok") {
            _1.logger.warn(`Config change request failed validation: ${JSON.stringify(validationResult)}`);
            return validationResult;
        }
        const passwordChanges = await (0, encrypt_1.encryptPasswordsInConfigFile)(config);
        // write config to file
        _1.logger.info("Writing config to file.");
        await (0, write_1.saveConfigToFile)(config, configFile);
        // storing factory config if needed
        if (cmd.setAsFactoryValue) {
            _1.logger.info("Storing changes as factory config.");
            let factoryConfStr;
            if ("path" in factoryConfigFile) {
                factoryConfStr = await fs.promises.readFile(factoryConfigFile.path, "utf8");
            }
            else {
                factoryConfStr = factoryConfigFile.contents;
            }
            const factoryConfig = JSON.parse(JSON.stringify(factoryConfStr));
            const res = (0, validate_1.changeConfig)(factoryConfig, changes);
            if (res.status !== "ok") {
                throw new Error("Failed to validate factory config after changing.");
            }
            await (0, write_1.saveConfigToFile)(factoryConfig, factoryConfigFile);
        }
        // update config and routing in redis
        state.config = config;
        _1.logger.info(changes, `Updating config in bus.`);
        changes = { ...changes, ...passwordChanges };
        await bus.setConfs(changes);
        await bus.setState((0, logic_1.calculateRouting)(config));
        if (changes["overvisVpn:boundToOcpServer"] !== undefined) {
            await bus.setState({
                boundToOcpServer: state.config.overvisVpn.boundToOcpServer,
                "overvisRc:mac": config.elan.mac || undefined,
            });
        }
        // run sync
        await bus.sendMsg(new opcb_ts_shared_1.redisBus.SyncConfig());
        // TODO_FUTURE: don't invoke sync routing if not changed
        await bus.sendMsg(new opcb_ts_shared_1.redisBus.SyncRouting());
        return validationResult;
    };
}
exports.createSetConfigHandler = createSetConfigHandler;
//# sourceMappingURL=handlers.js.map