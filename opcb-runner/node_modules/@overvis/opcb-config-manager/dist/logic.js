"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.walkSchema = exports.walkObj = exports.displayValidationError = exports.findFieldSchema = exports.calculateRouting = exports.flattenConfig = exports.applyDefaultConfigValues = void 0;
const util_1 = require("util");
function applyDefaultConfigValues(config, schema) {
    for (const [key, value] of Object.entries(schema)) {
        if (key === "properties") {
            for (const [prop, propSchema] of Object.entries(value)) {
                if (propSchema && typeof propSchema === "object") {
                    const propSchemaObj = propSchema;
                    if (propSchemaObj.default !== undefined) {
                        if (config[prop] === undefined) {
                            config[prop] = propSchemaObj.default;
                        }
                    }
                    if (propSchemaObj.properties) {
                        if (config[prop] === undefined) {
                            config[prop] = {};
                        }
                        applyDefaultConfigValues(config[prop], propSchemaObj);
                    }
                }
            }
        }
    }
}
exports.applyDefaultConfigValues = applyDefaultConfigValues;
function flattenConfig(config, root = "") {
    const setValues = {};
    for (const key in config) {
        if (key.startsWith("$")) {
            continue;
        }
        const path = root ? root + ":" + key : key;
        const v = config[key];
        if (v === null || v === undefined) {
            setValues[path] = null;
        }
        else if (typeof v === "object") {
            const addSetValues = flattenConfig(v, path);
            Object.assign(setValues, addSetValues);
        }
        else {
            setValues[path] = v.toString();
        }
    }
    return setValues;
}
exports.flattenConfig = flattenConfig;
function calculateRouting(config) {
    const routing = {};
    const virutalDeviceUid = config.virtualDevice.isEnabled ? config.virtualDevice.uid : undefined;
    if (virutalDeviceUid !== undefined) {
        routing["route:self"] = virutalDeviceUid.toFixed();
    }
    // eslint-disable-next-line @typescript-eslint/no-for-in-array
    for (const i in config.modbusRs485) {
        const port = config.modbusRs485[i];
        let range = port.uidRange;
        if (virutalDeviceUid !== undefined) {
            range = subtractFromRanges(range, virutalDeviceUid);
        }
        routing[`route:rs485:${i}`] = range;
    }
    // eslint-disable-next-line @typescript-eslint/no-for-in-array
    for (const i in config.modbusTcpClients) {
        const port = config.modbusTcpClients[i];
        let range = port.uidRange;
        if (virutalDeviceUid !== undefined) {
            range = subtractFromRanges(range, virutalDeviceUid);
        }
        routing[`route:mbtcpClient:${i}`] = range;
    }
    return routing;
}
exports.calculateRouting = calculateRouting;
function subtractFromRanges(rangesStr, uid) {
    const rangeStrs = rangesStr.split(",");
    const newRanges = [];
    for (const str of rangeStrs) {
        const [startStr, endStr] = str.split("-");
        const start = parseInt(startStr);
        const end = parseInt(endStr);
        if (start <= uid && uid <= end) {
            if (start < uid) {
                newRanges.push(`${start}-${(uid - 1).toFixed()}`);
            }
            if (uid < end) {
                newRanges.push(`${(uid + 1).toFixed()}-${end}`);
            }
        }
        else {
            newRanges.push(str);
        }
    }
    return newRanges.join(",");
}
function findFieldSchema(schema, path) {
    if (path.length === 0) {
        return schema;
    }
    const key = path[0];
    path = path.slice(1);
    if (schema.type === "object") {
        const subSchema = schema.properties[key];
        if (subSchema === undefined) {
            return undefined;
        }
        return findFieldSchema(subSchema, path);
    }
    else if (schema.type === "array") {
        if (path.length === 0) {
            return schema;
        }
        const subSchema = schema.items;
        if (subSchema === undefined) {
            return undefined;
        }
        return findFieldSchema(subSchema, path);
    }
    else {
        return undefined;
    }
}
exports.findFieldSchema = findFieldSchema;
function displayValidationError(e, json) {
    const str = `${e.path || ""} - ${e.message || ""}`;
    switch (e.type) {
        case "common":
        case "max-items": {
            const val = walkObj(json, e.path.split("/").filter((p) => p));
            return `${str}, current value: ${(0, util_1.inspect)(val)}`;
        }
        case "add-prop": {
            const path = e.path.split("/");
            return `${str}, additional property: ${path[path.length - 1]}`;
        }
        default:
            return str;
    }
}
exports.displayValidationError = displayValidationError;
function walkObj(obj, path) {
    for (const p of path) {
        obj = obj[p];
    }
    return obj;
}
exports.walkObj = walkObj;
function walkSchema(schema, path) {
    for (const p of path) {
        schema = schema.properties[p];
    }
    return schema;
}
exports.walkSchema = walkSchema;
//# sourceMappingURL=logic.js.map