"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readConfigFile = void 0;
const compiler_1 = require("@sinclair/typebox/compiler");
const util_1 = require("util");
const _1 = require(".");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const factory_1 = require("./factory");
const logic_1 = require("./logic");
const utils_1 = require("./utils");
const write_1 = require("./write");
async function readConfigFile(configFile, factoryConfigFile) {
    // read factory config
    let factoryConfJson;
    if ("path" in factoryConfigFile) {
        _1.logger.info(`Reading factory config from ${factoryConfigFile.path}`);
        factoryConfJson = (await (0, utils_1.loadConfigFile)(factoryConfigFile.path));
    }
    else {
        _1.logger.info(`Reading factory config from provided string.`);
        factoryConfJson = JSON.parse(factoryConfigFile.contents);
    }
    // read user config
    let userConfUnknown;
    try {
        if ("path" in configFile) {
            _1.logger.info(`Reading config from ${configFile.path}`);
            userConfUnknown = await (0, utils_1.loadConfigFile)(configFile.path);
        }
        else {
            _1.logger.info(`Reading config from provided string.`);
            userConfUnknown = JSON.parse(configFile.contents);
        }
    }
    catch (e) {
        _1.logger.warn(`Error retrieving or parsing JSON config file: ${e ? e.toString() : (0, util_1.inspect)(e)}`);
        _1.logger.warn(`Using empty config to restore default settings.`);
        userConfUnknown = {};
    }
    let userConfJson;
    if (!userConfUnknown ||
        typeof userConfUnknown !== "object" ||
        Array.isArray(userConfUnknown)) {
        _1.logger.warn(`Incorrect type of config JSON: ${(0, util_1.inspect)(userConfUnknown)}`);
        _1.logger.warn("Using empty config to restore default settings.");
        userConfJson = {};
    }
    else {
        userConfJson = userConfUnknown;
    }
    // // merge user config into factory config, leaving null values as is
    let fixed = (0, factory_1.mergeUserConfUponFactoryConf)(factoryConfJson, userConfJson);
    const confJson = factoryConfJson;
    // TODO_FUTURE: set default values in schema from factory config (in case if they are broken in userconf, they will be reset to default values below).
    // TODO_FUTURE: apply migrations
    let validate = compiler_1.TypeCompiler.Compile(opcb_ts_shared_1.CONFIG_SCHEMA);
    // validating resulting config
    let validated = false;
    let lastErrorsNum;
    for (let i = 0; i < 10; i++) {
        validated = validate.Check(confJson);
        if (validated) {
            break;
        }
        const errors = Array.from(validate.Errors(confJson));
        _1.logger.warn(`Config file contains errors. Attempting to fix...`);
        const cleanErrors = extractErrors(errors);
        if (lastErrorsNum === cleanErrors.length) {
            throw new Error("Last attempt errors were not fixed.");
        }
        lastErrorsNum = cleanErrors.length;
        for (const error of cleanErrors) {
            _1.logger.warn(`Config error: ${(0, logic_1.displayValidationError)(error, confJson)}`);
            const schemaChanged = attemptToFixError(confJson, error, opcb_ts_shared_1.CONFIG_SCHEMA);
            fixed = true;
            if (schemaChanged) {
                validate = compiler_1.TypeCompiler.Compile(opcb_ts_shared_1.CONFIG_SCHEMA);
            }
        }
        _1.logger.warn("Revalidating...");
    }
    if (!validated) {
        throw new Error("Can't validate the config file.");
    }
    // save config to file
    if (fixed) {
        _1.logger.warn(`Saving fixed config...`);
        await (0, write_1.saveConfigToFile)(confJson, configFile);
    }
    return [confJson, validate];
}
exports.readConfigFile = readConfigFile;
function extractErrors(errors) {
    const map = new Map();
    for (const err of errors) {
        let existingError = map.get(err.path);
        let type = (existingError === null || existingError === void 0 ? void 0 : existingError.type) || "common";
        if (err.type === compiler_1.ValueErrorType.ArrayMinItems) {
            type = "max-items";
        }
        else if (err.type === compiler_1.ValueErrorType.ObjectAdditionalProperties) {
            type = "add-prop";
        }
        if (!existingError) {
            existingError = {
                type,
                path: err.path,
                message: err.message,
                default: err.schema.default,
                limit: err.schema.maxItems,
            };
            map.set(err.path, existingError);
            continue;
        }
        existingError.type = type;
        existingError.default = err.schema.default;
        existingError.limit = err.schema.maxItems
            ? err.schema.maxItems
            : existingError.limit;
    }
    return Array.from(map.values()).sort((a) => (a.type === "max-items" ? 1 : -1));
}
function attemptToFixError(confJson, error, schema) {
    const path = error.path.split("/").filter((p) => p !== "");
    const property = path[path.length - 1];
    if (error.type === "max-items") {
        if (!error.limit) {
            throw new Error("Error maxItems, limit is empty.");
        }
        const obj = (0, logic_1.walkObj)(confJson, path.slice(0, -1));
        const array = obj[property];
        if (!Array.isArray(array)) {
            throw new Error("Got maxItems validation error for non-array: " + (0, util_1.inspect)(array));
        }
        _1.logger.warn(`Truncated ${error.path} to ${error.limit} items.`);
        array.splice(error.limit);
        return false;
    }
    else if (error.type === "add-prop") {
        const schemaObj = (0, logic_1.walkSchema)(schema, error.path.split("/").slice(1, -1));
        schemaObj.additionalProperties = true;
        _1.logger.warn(`Ignoring ${error.path}`);
        return true;
    }
    const defaultValue = error.default;
    const obj = (0, logic_1.walkObj)(confJson, path.slice(0, -1));
    obj[property] = defaultValue;
    _1.logger.warn(`Set ${error.path} = ${(0, util_1.inspect)(error.default)}`);
    return false;
}
//# sourceMappingURL=readconf.js.map