"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateConfigChanges = exports.changeConfig = void 0;
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const logic_1 = require("./logic");
function changeConfig(config, changes) {
    const schema = opcb_ts_shared_1.CONFIG_SCHEMA;
    // copying changes to avoid modifying the original object outside of this function
    const cleanedChanges = Object.assign({}, changes);
    // clear array contents if requested first
    for (const key in cleanedChanges) {
        if (!key.endsWith("*")) {
            continue;
        }
        const path = key.split(":").slice(0, -1);
        const fieldSchema = (0, logic_1.findFieldSchema)(schema, path);
        if (!fieldSchema) {
            return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectKey,
                key,
            });
        }
        if (fieldSchema.type !== "array") {
            return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectKey,
                key,
            });
        }
        // set empty array as a value
        const err = replaceInObj(config, path.join(":"), []);
        if (err) {
            return err;
        }
        // remove the key from changes (used outside of this function)
        delete cleanedChanges[key];
    }
    for (const key in cleanedChanges) {
        const path = key.split(":");
        // find the field schema
        const fieldSchema = (0, logic_1.findFieldSchema)(schema, path);
        if (!fieldSchema) {
            return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectKey,
                key,
            });
        }
        // convert type to the correct value
        const requestedValue = cleanedChanges[key];
        let actualValue;
        let fieldType;
        let nullable = false;
        let stype = fieldSchema.type;
        if (!stype && fieldSchema.anyOf) {
            stype = [];
            for (const literal of fieldSchema.anyOf) {
                stype.push(literal.type);
            }
        }
        if (!stype) {
            throw new Error("type is undefined.");
        }
        if (Array.isArray(stype)) {
            if (stype.includes("null")) {
                nullable = true;
                stype = stype.filter((v) => v !== "null");
            }
            fieldType = stype[0];
        }
        else {
            fieldType = stype;
        }
        if (requestedValue === null) {
            if (nullable) {
                actualValue = null;
            }
            else {
                return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                    code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectValue,
                    key,
                });
            }
        }
        else if (fieldType === "boolean") {
            if (requestedValue === "true") {
                actualValue = true;
            }
            else if (requestedValue === "false") {
                actualValue = false;
            }
            else {
                return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                    code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectValue,
                    key,
                });
            }
        }
        else if (fieldType === "number" || fieldType === "integer") {
            actualValue = Number(requestedValue);
            if (isNaN(actualValue)) {
                return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                    code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectValue,
                    key,
                });
            }
        }
        else if (fieldType === "string") {
            actualValue = requestedValue;
        }
        else if (fieldType === "array") {
            // arrays can only be fully cleared by the procedure in the beginning of this function (setting path:to:array:* to null)
            return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectValue,
                key,
            });
            // // special case: deleting item from the array by setting it to null
            // if (v === "null") {
            //     const index = Number(path[path.length - 1]);
            //     let obj = config as unknown as Record<string, unknown>;
            //     for (let i = 0; i < path.length - 1; i++) {
            //         obj = obj[path[i]] as Record<string, unknown>;
            //     }
            //     const array = obj as unknown as unknown[];
            //     if (array === undefined) {
            //         return new redisBus.ConfigValidationResponse({
            //             code: redisBus.ConfigValidationErrorCode.IncorrectKey,
            //             key,
            //         });
            //     }
            //     array.splice(index, 1);
            //     continue;
            // } else {
            //     return new redisBus.ConfigValidationResponse({
            //         code: redisBus.ConfigValidationErrorCode.IncorrectValue,
            //         key,
            //     });
            // }
        }
        else {
            return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
                code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectValue,
                key,
            });
        }
        // set config value
        const err = replaceInObj(config, key, actualValue);
        if (err) {
            return err;
        }
    }
    return new opcb_ts_shared_1.redisBus.ConfigValidationResponse("ok");
}
exports.changeConfig = changeConfig;
function replaceInObj(obj, key, value) {
    const path = key.split(":");
    for (let i = 0; i < path.length - 1; i++) {
        let newobj = obj[path[i]];
        if (newobj === undefined) {
            // always create non-existing paths because arrays can be fully cleared prior to this operation. we only support one-level arrays (no sub-arrays).
            newobj = {};
            obj[path[i]] = newobj;
            // if (createNonExistingPaths) {
            //     newobj = {};
            //     obj[path[i]] = newobj;
            // } else {
            //     return new redisBus.ConfigValidationResponse({
            //         code: redisBus.ConfigValidationErrorCode.IncorrectKey,
            //         key,
            //     });
            // }
        }
        obj = newobj;
    }
    obj[path[path.length - 1]] = value;
    return undefined;
}
function validateConfigChanges(config, changes, validate) {
    var _a;
    // replace values from the command
    const res = changeConfig(config, changes);
    if (res.status !== "ok") {
        return res;
    }
    // validate cloned config
    const valid = validate.Check(config);
    if (!valid) {
        const error = Array.from(validate.Errors(config))[0];
        if (!error) {
            throw new Error("No validation error returned by Typebox.");
        }
        return new opcb_ts_shared_1.redisBus.ConfigValidationResponse({
            code: opcb_ts_shared_1.redisBus.ConfigValidationErrorCode.IncorrectValue,
            key: (_a = error.path.split("/").slice(1).join(":")) !== null && _a !== void 0 ? _a : "???",
        });
    }
    return new opcb_ts_shared_1.redisBus.ConfigValidationResponse("ok");
}
exports.validateConfigChanges = validateConfigChanges;
//# sourceMappingURL=validate.js.map