"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkCommandFiles = void 0;
const tslib_1 = require("tslib");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const fs = tslib_1.__importStar(require("fs"));
const __1 = require("..");
const exec_1 = require("../exec");
async function checkCommandFiles(state, bus) {
    var _a;
    const res = {};
    // Mounting new devices
    const devDirContents = await fs.promises.readdir("/dev");
    const mntDirContents = await fs.promises.readdir("/mnt");
    const cmdFilesToAdd = [];
    for (const entry of devDirContents) {
        if (!entry.startsWith("sd")) {
            continue;
        }
        if (mntDirContents.includes(entry)) {
            continue;
        }
        // Mount device
        const devPath = `/dev/${entry}`;
        const mntPath = `/mnt/${entry}`;
        __1.logger.info(`Found new sd device: ${devPath}, mounting to ${mntPath}`);
        await (0, exec_1.exec)("mkdir", ["-p", mntPath]);
        const [_out, code] = await (0, exec_1.execCmd)("mount", [
            "--no-mtab",
            // "--read-only",
            devPath,
            mntPath,
        ]);
        if (code) {
            __1.logger.error(`Failed to mount ${devPath} to ${mntPath}: exit code ${code}`);
            continue;
        }
        // Checking files
        const files = await fs.promises.readdir(mntPath);
        // RESET_CONF
        if (files.includes("RESET_CONF")) {
            __1.logger.warn(`Found RESET_CONF on ${devPath}, resetting config...`);
            cmdFilesToAdd.push(`${mntPath}/RESET_CONF`);
            await bus.sendMsg(new opcb_ts_shared_1.redisCmd.ResetConfig());
        }
        // UNBIND_ACCOUNT
        if (files.includes("UNBIND_ACCOUNT")) {
            __1.logger.warn(`Found UNBIND_ACCOUNT on ${devPath}, temporary cleaning boundToOcpServer state...`);
            cmdFilesToAdd.push(`${mntPath}/UNBIND_ACCOUNT`);
            state.unbindAccountFromDev = entry;
            res.boundToOcpServer = "";
        }
        // SSH_AUTH_KEY
        if (files.includes("SSH_AUTH_KEY")) {
            __1.logger.warn(`Found SSH_AUTH_KEY on ${devPath}, processing user SSH key...`);
            cmdFilesToAdd.push(`${mntPath}/SSH_AUTH_KEY`);
            const key = await (0, exec_1.getFileContents)(`${mntPath}/SSH_AUTH_KEY`);
            // TODO_FUTURE: check key is broken
            if (!key) {
                __1.logger.warn("SSH_AUTH_KEY is empty.");
            }
            else {
                // TODO_FUTURE: add key to the config for automatic adding to the 'authorized_keys'
                await (0, exec_1.ensureFileContainsString)("/root/.ssh/authorized_keys", key);
            }
        }
        // OPCB_INFO
        if (files.includes("OPCB_INFO")) {
            __1.logger.warn(`Found OPCB_INFO on ${devPath}, write information to the file...`);
            cmdFilesToAdd.push(`${mntPath}/OPCB_INFO`);
            // Getting config and status data
            const { "overvisVpn:pinCode": pinCode } = await bus.getConfs(["overvisVpn:pinCode"]);
            const { "release:version": opcbVersion, "wlan:available": wifiAvailable, "wlan:isAp": wifiIsAp, "wlan:ssid": wifiSsid, "wlan:ip": wifiIp, "elan:ip": elanIp, "overvisRc:mac": macAddress, "wg:ip": wgIp, "wg:available": wgAvailable, "wg:pubkey": wgPubkey, } = await bus.getState([
                "release:version",
                "wlan:available",
                "wlan:isAp",
                "wlan:ssid",
                "wlan:ip",
                "elan:ip",
                "overvisRc:mac",
                "wg:ip",
                "wg:available",
                "wg:pubkey",
            ]);
            // Create info object
            const infoObj = {
                opcbVersion,
                elanIp,
                wifiMode: wifiAvailable !== "true"
                    ? "disabled"
                    : wifiIsAp === "true"
                        ? "wifi-ap"
                        : "wifi-sta",
                wifiSsid,
                wifiIp,
                mac: macAddress,
                wgAvailable,
                wgIp,
                wgPubkey,
                pinCode,
                overvisUrl: pinCode ? `http://c.overvis.com/${pinCode}` : undefined,
            };
            for (const k of Object.keys(infoObj)) {
                infoObj[k] = infoObj[k] === undefined ? null : infoObj[k];
            }
            // Save opcb information to the file 'OPCB_INFO'
            await fs.promises.writeFile(`${mntPath}/OPCB_INFO`, JSON.stringify(infoObj, null, 4), "utf8");
        }
    }
    // Unmounting old devices
    const cmdDirsToRemove = [];
    for (const entry of mntDirContents) {
        if (!entry.startsWith("sd")) {
            continue;
        }
        if (devDirContents.includes(entry)) {
            continue;
        }
        const mntPath = `/mnt/${entry}`;
        cmdDirsToRemove.push(`${mntPath}/`);
        __1.logger.info(`Unmounting ${mntPath}...`);
        const [_out, code] = await (0, exec_1.execCmd)("umount", [mntPath]);
        if (code) {
            __1.logger.error(`Failed to unmount ${mntPath}: exit code ${code}`);
        }
        __1.logger.debug(`Removing ${mntPath}...`);
        const [_, rmcode] = await (0, exec_1.execCmd)("rm", ["-r", mntPath]);
        if (rmcode) {
            __1.logger.error(`Failed to remove ${mntPath}: exit code ${rmcode}`);
        }
        if (state.unbindAccountFromDev === entry) {
            __1.logger.warn("Restoring boundToOcpServer state...");
            const val = (await bus.getConfs(["overvisVpn:boundToOcpServer"]))["overvisVpn:boundToOcpServer"];
            res.boundToOcpServer = val;
        }
    }
    // Need to update state 'sys:cmdFiles'
    if (cmdFilesToAdd.length > 0 || cmdDirsToRemove.length > 0) {
        const state = await bus.getState(["sys:cmdFiles"]);
        let files = ((_a = state["sys:cmdFiles"]) === null || _a === void 0 ? void 0 : _a.split(",")) || [];
        if (cmdFilesToAdd.length > 0) {
            files.push(...cmdFilesToAdd);
        }
        for (const d of cmdDirsToRemove) {
            files = files.filter((s) => !s.startsWith(d));
        }
        res["sys:cmdFiles"] = files.length === 0 ? undefined : files.join(",");
    }
    return res;
}
exports.checkCommandFiles = checkCommandFiles;
//# sourceMappingURL=cmdfiles.js.map