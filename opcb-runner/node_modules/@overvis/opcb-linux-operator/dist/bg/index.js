"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BgWorker = void 0;
const __1 = require("..");
class BgWorker {
    constructor(bus, state) {
        this.bus = bus;
        this.state = state;
        this.jobs = new Map();
        this.activeModeForMs = 0;
        this.isCurrentlyRunning = false;
        this.cycleLengthMs = 1000;
        this.forcedRunQueued = false;
    }
    hasJob(name) {
        return this.jobs.has(name);
    }
    addJob(name, fun, activeModeRefreshIntervalMs, bgModeRefreshIntervalMs) {
        if (!this.jobs.has(name)) {
            __1.logger.debug(`Bgworker job added: ${name}`);
        }
        this.jobs.set(name, {
            fun,
            activeModeRefreshIntervalMs,
            bgModeRefreshIntervalMs,
        });
    }
    removeJob(name) {
        if (!(name in this.jobs)) {
            return;
        }
        this.jobs.delete(name);
        __1.logger.debug(`Bgworker job removed: ${name}`);
    }
    setActiveModeFor(ms) {
        this.activeModeForMs = ms;
        this.activeModeSince = Date.now();
    }
    async start() {
        while (true) {
            const startOn = Date.now();
            if (this.forcedRunQueued) {
                this.forcedRunQueued = false;
                await this.run(true);
            }
            else {
                await this.run();
            }
            const endOn = Date.now();
            const sleepMs = Math.max(0, this.cycleLengthMs - (endOn - startOn));
            await new Promise((resolve) => setTimeout(resolve, sleepMs));
        }
    }
    async run(force) {
        if (this.isCurrentlyRunning || !this.state) {
            if (force) {
                this.forcedRunQueued = true;
            }
            return;
        }
        this.isCurrentlyRunning = true;
        const state = this.state;
        const promises = [];
        for (const [name, job] of this.jobs.entries()) {
            const activeMode = this.activeModeSince && this.activeModeSince + this.activeModeForMs > Date.now();
            const refreshIntervalMs = activeMode
                ? job.activeModeRefreshIntervalMs
                : job.bgModeRefreshIntervalMs;
            const shouldRun = force ||
                !job.lastRunOn ||
                Math.abs(Date.now() - job.lastRunOn) > refreshIntervalMs;
            if (!shouldRun) {
                continue;
            }
            job.lastRunOn = Date.now();
            promises.push((async () => {
                __1.logger.trace(`Job started: ${name}`);
                const startTime = Date.now();
                const res = await job.fun(state, this.bus);
                const endTime = Date.now();
                __1.logger.trace(`Job ended: ${name}`);
                const duration = endTime - startTime;
                if (duration > 1000) {
                    __1.logger.warn(`Job ${name} took ${duration}ms to execute.`);
                }
                return res;
            })());
        }
        const results = await Promise.all(promises);
        const stateChanges = Object.assign({}, ...results);
        if (Object.keys(stateChanges).length > 0) {
            __1.logger.trace(`Job state changes: ${JSON.stringify(stateChanges)}`);
        }
        await this.bus.setState(stateChanges);
        this.isCurrentlyRunning = false;
    }
}
exports.BgWorker = BgWorker;
//# sourceMappingURL=index.js.map