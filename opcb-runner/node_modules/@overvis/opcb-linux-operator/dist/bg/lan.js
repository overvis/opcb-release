"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateElanWlanStatus = void 0;
const tslib_1 = require("tslib");
const os = tslib_1.__importStar(require("os"));
const exec_1 = require("../exec");
const __1 = require("..");
async function updateElanWlanStatus(state, elanIface, wlanIface, manageNetworking) {
    const ifaces = os.networkInterfaces();
    // get elan details
    let elanAvalable = false;
    let elanIp = "";
    let elanMask = "";
    if (elanIface) {
        const infos = ifaces[elanIface];
        if (infos) {
            for (const info of infos) {
                if (info.family === "IPv4") {
                    elanAvalable = true;
                    elanIp = info.address;
                    elanMask = info.netmask;
                    break;
                }
            }
        }
    }
    // get wlan details
    let wlanAvalable = false;
    let wlanIp = "";
    let wlanMask = "";
    if (wlanIface) {
        const infos = ifaces[wlanIface];
        if (infos) {
            for (const info of infos) {
                if (info.family === "IPv4") {
                    wlanAvalable = true;
                    wlanIp = info.address;
                    wlanMask = info.netmask;
                    break;
                }
            }
        }
    }
    // get gateway ips
    const [out, code] = await (0, exec_1.execCmd)("ip", ["-j", "route"], "silent");
    let elanGatewayIp = "";
    let elanDhcpEnabled = false;
    let wlanGatewayIp = "";
    if (code !== 0) {
        __1.logger.error(`updateElanWlanStatus: failed to retrieve routes. ` +
            `ip route failed with code: ${code || "null"}`);
    }
    else {
        const items = JSON.parse(out);
        for (const item of items) {
            if (elanIface && item.dst === "default" && item.dev === elanIface) {
                elanGatewayIp = item.gateway;
                elanDhcpEnabled = item.protocol === "dhcp";
                state.elanGateway = elanGatewayIp;
            }
            if (wlanIface && item.dst === "default" && item.dev === wlanIface) {
                wlanGatewayIp = item.gateway;
                state.wlanGateway = wlanGatewayIp;
            }
        }
    }
    // get wlan additional infos
    let wlanSsid;
    let wlanIsAp = false;
    let wlanChannel;
    let wlanBand;
    if (wlanIface && manageNetworking) {
        const wlanInfoStr = await (0, exec_1.execCmd)("nmcli", [
            "-t",
            "-f",
            "802-11-wireless.mode,802-11-wireless.ssid,802-11-wireless.channel,802-11-wireless.band",
            "connection",
            "show",
            "opcb-wlan",
        ]);
        if (!wlanInfoStr[1]) {
            const wlanInfo = Object.fromEntries(wlanInfoStr[0]
                .trim()
                .split("\n")
                .map((s) => s.split(":").map((s) => s.trim())));
            wlanSsid = wlanInfo["802-11-wireless.ssid"];
            wlanIsAp = wlanInfo["802-11-wireless.mode"] === "ap";
            wlanChannel = wlanInfo["802-11-wireless.channel"]
                ? parseInt(wlanInfo["802-11-wireless.channel"], 10)
                : undefined;
            wlanBand = wlanInfo["802-11-wireless.band"];
        }
    }
    return {
        "elan:iface": elanIface,
        "elan:available": elanAvalable,
        "elan:ip": elanIp,
        "elan:mask": elanMask,
        "elan:gatewayIp": elanGatewayIp,
        "elan:dhcpEnabled": elanDhcpEnabled,
        "wlan:iface": wlanIface,
        "wlan:available": wlanAvalable,
        "wlan:ip": wlanIp,
        "wlan:mask": wlanMask,
        "wlan:gatewayIp": wlanGatewayIp,
        "wlan:ssid": wlanSsid,
        "wlan:isAp": wlanIsAp,
        "wlan:channel": wlanChannel,
        "wlan:band": wlanBand,
    };
}
exports.updateElanWlanStatus = updateElanWlanStatus;
//# sourceMappingURL=lan.js.map