"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkForUpdates = void 0;
const tslib_1 = require("tslib");
const server_tools_1 = require("@overvis/server-tools");
const fs = tslib_1.__importStar(require("fs"));
const __1 = require("..");
const exec_1 = require("../exec");
function convertVersionToNum(versionStr) {
    const digits = versionStr.split(".");
    if (digits.length !== 2) {
        return 0;
    }
    return Number(digits[0]) * 100 + Number(digits[1]);
}
// TODO_FUTURE: mode "auto-all" should upgrade to the latest commit in the branch opcb
// TODO_FUTURE: maybe use model as a branch/tag prefix?
async function checkForUpdates(updateMode, allowForcedUpdates) {
    __1.logger.info("Determining the current version and checking for updates...");
    // TODO_FUTURE: move to runner config
    const cwd = process.cwd() + "/..";
    if (!fs.existsSync(`${cwd}/.git`)) {
        __1.logger.info("No git repository available, trying to read current version from VERSION file. Updates are disabled.");
        let version;
        try {
            version = fs.readFileSync(`${cwd}/VERSION`).toString().trim();
        }
        catch (e) {
            __1.logger.warn("Could not read version from VERSION file.");
            version = `unknown version`;
        }
        return {
            "release:version": version,
            "release:versionNum": convertVersionToNum(version).toString(),
            "release:model": "opcb",
            "release:updateState": "no-repo",
            "release:scheduledUpgradeToTag": undefined,
        };
    }
    const desc = await (0, exec_1.exec)("git describe --tags --dirty --broken --always --long --match='opcb/*.*.*'");
    const parts = desc.trim().split("-");
    const tag = parts[0];
    const version = tag.split("/")[1];
    const sha = parts[2].slice(1);
    const dirty = parts[3] === "dirty";
    const broken = parts[3] === "broken";
    const date = (await (0, exec_1.exec)("git show -s --format=%cs HEAD")).trim();
    (0, server_tools_1.setSentryContext)({ version: `${desc.trim()} (${date})` });
    __1.logger.info(`Retrieved current version: ${version}@${sha} (${date}).`);
    const result = {
        "release:tag": tag,
        "release:version": version,
        "release:sha": sha,
        "release:date": date,
        "release:versionNum": convertVersionToNum(version).toString(),
        "release:model": "opcb",
        "release:scheduledUpgradeToTag": undefined,
    };
    if (updateMode === "disabled") {
        __1.logger.info("Updates are disabled, skipping the update check.");
        result["release:updateState"] = "disabled";
        return result;
    }
    if (broken) {
        __1.logger.error(`Git repository is broken. Updates are disabled. ` +
            `Please contact support to have assistance in fixing this issue.`);
        result["release:updateState"] = "broken-repo";
        return result;
    }
    if (dirty && !allowForcedUpdates) {
        __1.logger.warn(`Git repository is dirty, updates are disabled. ` +
            `Please stash your changes to enable the updates.`);
        result["release:updateState"] = "dirty-repo";
        return result;
    }
    __1.logger.info("Running git fetch...");
    const [_out, code] = await (0, exec_1.execCmd)("git fetch --prune --prune-tags --atomic --tags origin tag opcb/*");
    if (code !== 0) {
        __1.logger.warn(`Failed to fetch updates. Please check your internet connection. ` +
            `Updates are disabled for this session.`);
        result["release:updateState"] = "no-update";
        return result;
    }
    __1.logger.info("Git fetch done.");
    const tagsStr = await (0, exec_1.exec)("git tag --list 'opcb/*.*.*' --color=never --no-column --contains");
    const tags = tagsStr
        .trim()
        .split("\n")
        .filter((t) => t !== tag)
        .map((t) => t.trim());
    result["release:updateState"] = "no-update";
    if (!tagsStr || tags.length === 0) {
        __1.logger.info("No updates available.");
        return result;
    }
    __1.logger.info("New tags are available: " + tags.join(", "));
    // TODO_FUTURE: encapsulate and test
    const [currentMajor, currentMinor, currentPatch] = version.split(".").map((s) => Number(s));
    let latestPatch;
    let latestMinor;
    let latestMajor;
    for (const tag of tags) {
        const versionStr = tag.split("/")[1];
        if (!versionStr) {
            continue;
        }
        const versionParts = versionStr.split(".");
        if (versionParts.length !== 3) {
            continue;
        }
        const [major, minor, patch] = versionParts.map((s) => Number(s));
        if (major < currentMajor ||
            (major === currentMajor && minor < currentMinor) ||
            (major === currentMajor && minor === currentMinor && patch <= currentPatch)) {
            continue;
        }
        else if (major === currentMajor && minor === currentMinor) {
            if (!latestPatch || patch > latestPatch[1]) {
                latestPatch = [tag, patch];
            }
        }
        else if (major === currentMajor) {
            if (!latestMinor ||
                minor > latestMinor[1] ||
                (minor === latestMinor[1] && patch > latestMinor[2])) {
                latestMinor = [tag, minor, patch];
            }
        }
        else {
            if (!latestMajor ||
                major > latestMajor[1] ||
                (major === latestMajor[1] && minor > latestMajor[2]) ||
                (major === latestMajor[1] && minor === latestMajor[2] && patch > latestMajor[3])) {
                latestMajor = [tag, major, minor, patch];
            }
        }
    }
    if (latestPatch) {
        __1.logger.info(`Found a patch update: ${latestPatch[0]}`);
        await setUpdateInfo(latestPatch[0], version, result, "release:latestPatch");
    }
    if (latestMinor) {
        __1.logger.info(`Found a minor update: ${latestMinor[0]}`);
        await setUpdateInfo(latestMinor[0], version, result, "release:latestMinor");
    }
    if (latestMajor) {
        __1.logger.info(`Found a major update: ${latestMajor[0]}`);
        await setUpdateInfo(latestMajor[0], version, result, "release:latestMajor");
    }
    // TODO_FUTURE: if imminent upgrade - exit, leave release:updateState as "imminent-upgrade"
    if (updateMode === "manual") {
        __1.logger.info("Automatic updates are disabled, ignoring.");
        if (latestPatch) {
            result["release:updateState"] = "available-update-patch";
        }
        else if (latestMinor) {
            result["release:updateState"] = "available-update-minor";
        }
        else if (latestMajor) {
            result["release:updateState"] = "available-update-major";
        }
        return result;
    }
    let upgradeToTag;
    if (latestPatch) {
        result["release:updateState"] = "available-update-patch";
        upgradeToTag = latestPatch[0];
    }
    if (latestMinor && (updateMode === "auto-all" || updateMode === "auto-only-minor")) {
        result["release:updateState"] = "available-update-minor";
        upgradeToTag = latestMinor[0];
    }
    if (latestMajor && updateMode === "auto-all") {
        result["release:updateState"] = "available-update-major";
        upgradeToTag = latestMajor[0];
    }
    if (upgradeToTag) {
        __1.logger.info(`Scheduling upgrade to ${upgradeToTag}.`);
    }
    result["release:scheduledUpgradeToTag"] = upgradeToTag;
    return result;
}
exports.checkForUpdates = checkForUpdates;
async function setUpdateInfo(tag, currentVersion, result, prefix) {
    const updateVersion = tag.split("/")[1];
    const [updateSha, updateDate] = (await (0, exec_1.exec)(`git show -s --format='%h %cs' ${tag}`))
        .trim()
        .split(" ");
    const updateChangelog = processChangelog(await (0, exec_1.exec)(`git show ${tag}:CHANGELOG.md`), currentVersion);
    result[`${prefix}:tag`] = tag;
    result[`${prefix}:version`] = updateVersion;
    result[`${prefix}:date`] = updateDate;
    result[`${prefix}:changelog`] = updateChangelog;
    result[`${prefix}:sha`] = updateSha;
}
function processChangelog(raw, tillVersion) {
    let result = "";
    let started = false;
    for (const line of raw.split("\n")) {
        if (line.startsWith(`## `) && !line.startsWith(`## Unreleased`)) {
            started = true;
        }
        if (line.startsWith(`## [${tillVersion}]`)) {
            return result;
        }
        if (started) {
            result += line + "\n";
        }
    }
    return result;
}
//# sourceMappingURL=update.js.map