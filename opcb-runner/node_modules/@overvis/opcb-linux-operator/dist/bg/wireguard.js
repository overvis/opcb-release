"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateWgInfo = void 0;
const tslib_1 = require("tslib");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const os = tslib_1.__importStar(require("os"));
const __1 = require("..");
const exec_1 = require("../exec");
async function getWireguardDump() {
    const [out, code, err] = await (0, exec_1.execCmd)("wg", ["show", "wg0", "dump"], "silent");
    if (code) {
        __1.logger.warn(`"wg show wg0 dump" exited with code ${code}:\n${out}\n${err}`);
        // TODO_FUTURE: try to restart service?
        return;
    }
    const lines = out.trim().split("\n");
    if (lines.length < 2) {
        return;
    }
    const [servStr, ...peerStrs] = lines;
    const [_privateKey, publicKey, listenPortStr, _fwMark] = servStr.trim().split("\t");
    const peers = peerStrs.map((peerStr) => {
        const [publicKey, _presharedKey, endpoint, allowedIps, latestHandshake, transferRx, transferTx, persistentKeepalive,] = peerStr
            .trim()
            .split("\t")
            .map((s) => s.trim());
        return {
            publicKey,
            endpoint,
            allowedIPs: allowedIps === "(none)" ? [] : allowedIps.split(",").map((s) => s.trim()),
            latestHandshake: new Date(parseInt(latestHandshake, 10) * 1000),
            rx: parseInt(transferRx, 10),
            tx: parseInt(transferTx, 10),
            persistentKeepalive: persistentKeepalive !== "off" ? parseInt(persistentKeepalive, 10) : undefined,
        };
    });
    return {
        publicKey,
        listenPort: parseInt(listenPortStr, 10),
        peers,
    };
}
async function updateWgInfo(vpnMotherlandServerIp) {
    const dump = await getWireguardDump();
    if (!dump) {
        return {
            "wg:available": false,
            "wg:pubkey": "",
            "wg:ip": "",
            "wg:mask": "",
            "wg:endpointAddress": "",
            "wg:endpointPubkey": "",
            "wg:ping": "unreachable",
        };
    }
    (0, opcb_ts_shared_1.setSentryContext)({ pubKey: dump.publicKey });
    let wgIp = "";
    let wgMask = "";
    const ifaces = os.networkInterfaces();
    const infos = ifaces.wg0;
    if (infos) {
        for (const info of infos) {
            if (info.family === "IPv4") {
                wgIp = info.address;
                wgMask = info.netmask;
                break;
            }
        }
    }
    if (!wgIp) {
        return {
            "wg:available": false,
            "wg:pubkey": "",
            "wg:ip": "",
            "wg:mask": "",
            "wg:endpointAddress": "",
            "wg:endpointPubkey": "",
            "wg:ping": "unreachable",
        };
    }
    (0, opcb_ts_shared_1.setSentryContext)({ wgIp });
    const wgPing = await (0, exec_1.ping)(vpnMotherlandServerIp);
    return {
        "wg:available": true,
        "wg:pubkey": dump.publicKey,
        "wg:ip": wgIp,
        "wg:mask": wgMask,
        "wg:endpointAddress": dump.peers[0].endpoint,
        "wg:endpointPubkey": dump.peers[0].publicKey,
        "wg:ping": wgPing || "unreachable",
        "wg:rx:total": dump.peers[0].rx,
        "wg:tx:total": dump.peers[0].tx,
    };
}
exports.updateWgInfo = updateWgInfo;
//# sourceMappingURL=wireguard.js.map