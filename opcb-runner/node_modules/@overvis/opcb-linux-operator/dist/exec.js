"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileContents = exports.ping = exports.ensureServiceState = exports.serviceIsActive = exports.ensureFileContainsString = exports.ensureFileContents = exports.exec = exports.ExecError = exports.execCmd = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const _1 = require(".");
const childProcess = tslib_1.__importStar(require("child_process"));
async function execCmd(cmd, args = [], logLevel = "debug") {
    return new Promise((resolve, reject) => {
        let startCmd = cmd;
        if (args.length > 0) {
            startCmd += " " + args.join(" ");
        }
        const sublogger = _1.logger.child({ cmd: startCmd });
        const log = sublogger[logLevel].bind(sublogger);
        if (logLevel !== "silent") {
            sublogger.trace("starting process");
        }
        let stdout = "";
        let stderr = "";
        // TODO_FUTURE: make args undefined to decide to run in shell
        const cp = childProcess.spawn(cmd, args, { shell: !args.length });
        cp.on("spawn", () => {
            // NOTE: Code comented below is a memory leak. If needed to kill child processes on exit - make global list of currently running child processes and kill them on exit.
            // process.on("exit", () => {
            //     cp.kill();
            // });
            log("process started");
        });
        let rejected = false;
        cp.on("error", (err) => {
            sublogger.error({ err }, "process error");
            rejected = true;
            reject(err);
        });
        cp.on("close", (code, signal) => {
            if (rejected) {
                return;
            }
            log(`process exited with code ${code} (signal: ${signal})`);
            if (stdoutIncompleteLine.length > 0) {
                stdout += stdoutIncompleteLine;
            }
            if (stderrIncompleteLine.length > 0) {
                stderr += stderrIncompleteLine;
            }
            resolve([stdout, code, stderr]);
        });
        let stdoutIncompleteLine = "";
        cp.stdout.on("data", (data) => {
            const str = data.toString("utf8");
            stdout += str;
            const lines = str.split("\n");
            while (lines.length > 1) {
                log({ stdout: true }, stdoutIncompleteLine + lines.shift());
                stdoutIncompleteLine = "";
            }
            stdoutIncompleteLine = lines.shift();
        });
        let stderrIncompleteLine = "";
        cp.stderr.on("data", (data) => {
            const str = data.toString("utf8");
            stderr += str;
            const lines = str.split("\n");
            while (lines.length > 1) {
                log({ stderr: true }, stderrIncompleteLine + lines.shift());
                stderrIncompleteLine = "";
            }
            stderrIncompleteLine = lines.shift();
        });
    });
}
exports.execCmd = execCmd;
class ExecError extends Error {
    constructor(message, exitCode, output) {
        super(message);
        this.exitCode = exitCode;
        this.output = output;
    }
}
exports.ExecError = ExecError;
async function exec(cmd, args = [], logLevel = "debug") {
    const [out, code, err] = await execCmd(cmd, args, logLevel);
    if (code) {
        throw new ExecError(`Command failed with exit code ${code}`, code, `${out}\n${err}`);
    }
    return out;
}
exports.exec = exec;
async function ensureFileContents(filename, content, mode = 0o644) {
    let { fd, changed } = await ensureFileHasMode(filename, mode);
    try {
        const currentContent = await fd.readFile("utf8");
        if (currentContent !== content) {
            _1.logger.warn(`File content is not correct, updating: ${filename}`);
            await fd.truncate(0);
            await fd.write(content, 0, "utf8");
            changed = true;
        }
        else {
            _1.logger.trace(`File content is correct: ${filename}`);
        }
    }
    finally {
        await fd.close();
    }
    return changed;
}
exports.ensureFileContents = ensureFileContents;
async function ensureFileContainsString(filename, str, mode = 0o644) {
    let { fd, changed } = await ensureFileHasMode(filename, mode);
    try {
        const currentContent = await fd.readFile("utf8");
        if (!str.endsWith("\n")) {
            str = str + "\n";
        }
        if (!currentContent.includes(str)) {
            _1.logger.warn(`File content is not correct, fixing: ${filename}`);
            if (currentContent && !currentContent.endsWith("\n")) {
                str = "\n" + str;
            }
            await fd.write(str, null, "utf8");
            changed = true;
        }
        else {
            _1.logger.trace(`File content is correct: ${filename}`);
        }
    }
    finally {
        await fd.close();
    }
    return changed;
}
exports.ensureFileContainsString = ensureFileContainsString;
async function ensureFileHasMode(filename, mode) {
    let changed = false;
    let fd;
    try {
        fd = await fs.promises.open(filename, "r+");
        const stat = await fd.stat();
        const curmode = stat.mode & 0o777;
        if (curmode !== mode) {
            _1.logger.warn(`Changing mode of ${filename} to ${mode.toString(8)}`);
            await fd.chmod(mode);
            changed = true;
        }
    }
    catch (err) {
        if (err.code === "ENOENT") {
            _1.logger.debug(`File does not exist, creating: ${filename}`);
            fd = await fs.promises.open(filename, "w+", mode);
            changed = true;
        }
        else {
            if (fd) {
                await fd.close();
            }
            throw err;
        }
    }
    return { fd, changed };
}
async function serviceIsActive(name) {
    const active = (await exec(`systemctl is-active ${name} || true`)).trim();
    return active === "active";
}
exports.serviceIsActive = serviceIsActive;
async function ensureServiceState(name, isOn, restartReason) {
    _1.logger.debug(`Ensuring service '${name}' is ${isOn ? "started" : "stopped"}...`);
    // start/stop service
    const isActiveRes = await execCmd("systemctl", ["is-active", name]);
    if (isActiveRes[1] && isActiveRes[1] !== 3) {
        _1.logger.warn(`"systemctl is-active ${name}" exited with code: ${isActiveRes[1]}`);
    }
    const active = isActiveRes[0].trim();
    if (isOn && active !== "active") {
        _1.logger.warn(`Service ${name} is stopped, starting...`);
        await exec("systemctl", ["start", name], "info");
    }
    if (isOn && restartReason && active === "active") {
        _1.logger.info(`Service ${name} should be restarted: ${restartReason}...`);
        await exec("systemctl", ["restart", name], "info");
    }
    if (!isOn && active === "active") {
        _1.logger.warn(`Service ${name} is started, stopping...`);
        await exec("systemctl", ["stop", name], "info");
    }
    // enable/disable service
    const isEnabledRes = await execCmd("systemctl", ["is-enabled", name]);
    if (isEnabledRes[1] && isEnabledRes[1] !== 1) {
        _1.logger.warn(`"systemctl is-enabled ${name}" exited with code: ${isEnabledRes[1]}`);
    }
    const enabled = isEnabledRes[0].trim();
    if (isOn && enabled !== "enabled") {
        _1.logger.warn(`Service ${name} is disabled, enabling...`);
        await exec("systemctl", ["enable", name], "info");
    }
    if (!isOn && enabled === "enabled") {
        _1.logger.warn(`Service ${name} is enabled, disabling...`);
        await exec("systemctl", ["disable", name], "info");
    }
}
exports.ensureServiceState = ensureServiceState;
async function ping(ip, iface) {
    const args = ["-W", "0.5", "-q", "-c", "1"];
    if (iface) {
        args.push("-I", iface);
    }
    args.push(ip);
    const [out, code] = await execCmd("ping", args, "silent");
    if (code !== 0) {
        _1.logger.debug(`Ping ${ip}: fail (code: ${code || "null"})`);
        return;
    }
    const strs = out.split("\n");
    const time = Number(strs[strs.length - 2].split(" ")[3].split("/")[1]);
    _1.logger.trace(`Ping ${ip}: ${time}ms`);
    return time;
}
exports.ping = ping;
async function getFileContents(filename) {
    try {
        return await fs.promises.readFile(filename, "utf8");
    }
    catch (err) {
        if (err.code === "ENOENT") {
            return undefined;
        }
        throw err;
    }
}
exports.getFileContents = getFileContents;
//# sourceMappingURL=exec.js.map