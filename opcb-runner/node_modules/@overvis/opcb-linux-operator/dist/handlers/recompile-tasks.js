"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRecompileTasksHandler = void 0;
const tslib_1 = require("tslib");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const __1 = require("..");
const exec_1 = require("../exec");
function createRecompileTasksHandler(db, tasksProjectDir, bus) {
    const TRUNKATE_TASK_FILES_SQL = db.prepare(`delete from task_files;`);
    const INSERT_TASK_FILE_SQL = db.prepare(`insert into task_files (
                filepath,
                last_updated_on,
                task_name,
                task_description
            ) values (
                @filepath,
                @lastUpdatedOn,
                @taskName,
                @taskDescription
            );`);
    return async (_cmd) => {
        __1.logger.info("Got recompile tasks command.");
        __1.logger.debug("Recompiling task files...");
        try {
            const [out, code, err] = await (0, exec_1.execCmd)(`cd ${tasksProjectDir} && ./node_modules/.bin/esbuild ./src/**/*.ts  --tsconfig=./tsconfig.json --outdir=./dist --outbase=./src --sourcemap --platform=node --target=node18.2 --format=cjs`);
            if (code !== null && code !== 0) {
                __1.logger.warn(`Recompile tasks completed with error:\n${out}\n${err}`);
                return new opcb_ts_shared_1.redisCmd.Done(`Recompile tasks completed with error:\n${out}\n${err}`);
            }
        }
        catch (err) {
            // TODO_FUTURE: remove this catch to report this error on Sentry?
            const errStr = err instanceof Error ? err.toString() : JSON.stringify(err);
            __1.logger.warn(`Recompile tasks exec resulted in error:\n${errStr}`);
            return new opcb_ts_shared_1.redisCmd.Done(`Recompile tasks exec resulted in error:\n${errStr}`);
        }
        __1.logger.debug("Success.");
        const taskFiles = await gatherTasks(`${tasksProjectDir}/dist/tasks`);
        TRUNKATE_TASK_FILES_SQL.run();
        for (const taskFile of taskFiles) {
            INSERT_TASK_FILE_SQL.run({
                filepath: taskFile.filepath,
                lastUpdatedOn: taskFile.modifyTime.getTime() / 1000,
                taskName: taskFile.taskName || null,
                taskDescription: taskFile.taskDescription || null,
            });
        }
        __1.logger.info("Tasks recompilation done.");
        await bus.setState({ "tasks:lastCompilationOn": Date.now().toString() });
        return new opcb_ts_shared_1.redisCmd.Done();
    };
}
exports.createRecompileTasksHandler = createRecompileTasksHandler;
async function gatherTasks(dir) {
    const result = [];
    const fileList = await fs_1.default.promises.readdir(dir);
    for (const basename of fileList) {
        const fullPath = path_1.default.join(dir, basename);
        const stat = await fs_1.default.promises.stat(fullPath);
        if (stat.isDirectory()) {
            result.push(...(await gatherTasks(fullPath)));
        }
        else {
            const extname = path_1.default.extname(fullPath);
            if (extname === ".js") {
                const task = await readTaskFile(fullPath);
                task.modifyTime = stat.mtime;
                result.push(task);
            }
        }
    }
    return result;
}
const TASK_NAME_RE = /@opcbTaskName\s+(.+)$/m;
const TASK_DESCRIPTION_RE = /@opcbTaskDescription\s+(.+)$/m;
async function readTaskFile(filepath) {
    var _a, _b;
    const contents = await fs_1.default.promises.readFile(filepath, "utf-8");
    const taskName = ((_a = TASK_NAME_RE.exec(contents)) === null || _a === void 0 ? void 0 : _a[1]) || path_1.default.basename(filepath, ".js");
    const taskDescription = (_b = TASK_DESCRIPTION_RE.exec(contents)) === null || _b === void 0 ? void 0 : _b[1];
    return {
        filepath,
        modifyTime: new Date(0),
        taskDescription,
        taskName,
    };
}
//# sourceMappingURL=recompile-tasks.js.map