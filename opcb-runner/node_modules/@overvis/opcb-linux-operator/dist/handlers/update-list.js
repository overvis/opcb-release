"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUpdateListHandler = void 0;
const tslib_1 = require("tslib");
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const fs = tslib_1.__importStar(require("fs"));
const __1 = require("..");
const exec_1 = require("../exec");
function createUpdateListHandler(bus) {
    return async (cmd) => {
        __1.logger.debug(`Got update list '${cmd.name}' command.`);
        if (cmd.name === "netifs") {
            // NOTE: os.networkInterfaces() does not return down connections
            // const netifs = os.networkInterfaces();
            // const list = Object.keys(netifs);
            const res = JSON.parse(await (0, exec_1.exec)("ip", ["-j", "addr"]));
            const list = res.map((v) => v.ifname);
            await bus.setList(cmd.name, list);
        }
        else if (cmd.name === "serials") {
            const files = await fs.promises.readdir("/dev");
            let list = files.filter((f) => f.startsWith("ttyUSB"));
            if (list.length === 0) {
                list = ["ttyUSB0"];
            }
            await bus.setList(cmd.name, list);
        }
        else {
            const wlanNetif = (await bus.getConfs(["wlan:networkInterfaceName"]))["wlan:networkInterfaceName"] ||
                "wlan0";
            const aps = await getApsList(wlanNetif);
            if (aps) {
                await bus.setList(cmd.name, aps);
            }
        }
        return new opcb_ts_shared_1.redisCmd.Done();
    };
}
exports.createUpdateListHandler = createUpdateListHandler;
async function getApsList(wlanNetif) {
    const [out, code, err] = await (0, exec_1.execCmd)("/usr/bin/timeout --signal=SIGKILL 15 /usr/bin/sh -c " +
        `"iw dev ${wlanNetif} scan | ` +
        "grep -o 'BSS ..\\:..\\:..\\:..\\:..\\:..\\|SSID\\: .*\\|signal\\: .* \\|freq\\: .*'\"", [], "debug");
    if (code === 124 || code === 137) {
        __1.logger.warn("Timeout while scanning for access points.");
        return;
    }
    else if (code) {
        __1.logger.warn(`Failed to scan for access points (code ${code}):\n${out}\n${err}`);
        return;
    }
    let apBlocks = [];
    const strs = out.split("\n").map((s) => s.trim());
    // eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < strs.length; i++) {
        const line = strs[i];
        if (line.startsWith("BSS")) {
            apBlocks.push({ bss: line.slice(4) });
        }
        else if (line.startsWith("SSID:")) {
            apBlocks[apBlocks.length - 1].ssid = line.slice(6).replace("|", "-");
        }
        else if (line.startsWith("signal:")) {
            apBlocks[apBlocks.length - 1].signal = Number(line.split(" ")[1]);
        }
        else if (line.startsWith("freq:")) {
            apBlocks[apBlocks.length - 1].freq = Number(line.split(" ")[1]);
        }
    }
    apBlocks = apBlocks.filter((b) => b.ssid &&
        b.signal &&
        b.freq &&
        b.ssid !==
            "\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00");
    const aps = apBlocks.map((b) => {
        return `${b.ssid || ""}|${b.bss || ""}|${b.signal || ""}|${b.freq || ""}`;
    });
    return aps;
}
//# sourceMappingURL=update-list.js.map