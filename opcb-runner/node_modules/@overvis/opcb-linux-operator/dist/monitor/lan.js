"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateElanWlanStatus = void 0;
const tslib_1 = require("tslib");
const os = tslib_1.__importStar(require("os"));
const exec_1 = require("../exec");
async function updateElanWlanStatus(state) {
    // get elan details
    const ifaces = os.networkInterfaces();
    let elanAvalable = false;
    let elanIp = "";
    let elanMask = "";
    if (state.settings.elanIface) {
        const elanIface = ifaces[state.settings.elanIface];
        if (elanIface) {
            for (const iface of elanIface) {
                if (iface.family === "IPv4") {
                    elanAvalable = true;
                    elanIp = iface.address;
                    elanMask = iface.netmask;
                    break;
                }
            }
        }
    }
    // get wlan details
    let wlanAvalable = false;
    let wlanIp = "";
    let wlanMask = "";
    if (state.settings.wlanIface) {
        const wlanIface = ifaces[state.settings.wlanIface];
        if (wlanIface) {
            for (const iface of wlanIface) {
                if (iface.family === "IPv4") {
                    wlanAvalable = true;
                    wlanIp = iface.address;
                    wlanMask = iface.netmask;
                    break;
                }
            }
        }
    }
    // get gateway ips
    // if (!elanIfaceName || !wlanIfaceName) {
    //     return { "elan:gatewayIp": "", "wlan:gatewayIp": "" };
    // }
    const res = await (0, exec_1.execCmd)("ip", ["-j", "route"], "silent");
    const items = JSON.parse(res[0]);
    let elanGatewayIp = "";
    let elanDhcpEnabled = false;
    let wlanGatewayIp = "";
    for (const item of items) {
        if (state.settings.elanIface &&
            item.dst === "default" &&
            item.dev === state.settings.elanIface) {
            elanGatewayIp = item.gateway;
            elanDhcpEnabled = item.protocol === "dhcp";
            state.elanGateway = elanGatewayIp;
        }
        if (state.settings.wlanIface &&
            item.dst === "default" &&
            item.dev === state.settings.wlanIface) {
            wlanGatewayIp = item.gateway;
            state.wlanGateway = wlanGatewayIp;
        }
    }
    let wlanSsid;
    let wlanIsAp = false;
    let wlanChannel;
    let wlanBand;
    if (state.settings.wlanIface && state.settings.manageNetworking) {
        const wlanInfoStr = await (0, exec_1.execCmd)("nmcli", [
            "-t",
            "-f",
            "802-11-wireless.mode,802-11-wireless.ssid,802-11-wireless.channel,802-11-wireless.band",
            "connection",
            "show",
            "opcb-wlan",
        ]);
        if (!wlanInfoStr[1]) {
            const wlanInfo = Object.fromEntries(wlanInfoStr[0]
                .trim()
                .split("\n")
                .map((s) => s.split(":").map((s) => s.trim())));
            wlanSsid = wlanInfo["802-11-wireless.ssid"];
            wlanIsAp = wlanInfo["802-11-wireless.mode"] === "ap";
            wlanChannel = wlanInfo["802-11-wireless.channel"]
                ? parseInt(wlanInfo["802-11-wireless.channel"], 10)
                : undefined;
            wlanBand = wlanInfo["802-11-wireless.band"];
        }
    }
    return {
        "elan:iface": state.settings.elanIface,
        "elan:available": elanAvalable,
        "elan:ip": elanIp,
        "elan:mask": elanMask,
        "elan:gatewayIp": elanGatewayIp,
        "elan:dhcpEnabled": elanDhcpEnabled,
        "wlan:iface": state.settings.wlanIface,
        "wlan:available": wlanAvalable,
        "wlan:ip": wlanIp,
        "wlan:mask": wlanMask,
        "wlan:gatewayIp": wlanGatewayIp,
        "wlan:ssid": wlanSsid,
        "wlan:isAp": wlanIsAp,
        "wlan:channel": wlanChannel,
        "wlan:band": wlanBand,
    };
}
exports.updateElanWlanStatus = updateElanWlanStatus;
//# sourceMappingURL=lan.js.map