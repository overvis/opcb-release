"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonitorRunner = void 0;
const __1 = require("..");
class MonitorRunner {
    constructor(bus) {
        this.bus = bus;
        this.runners = {};
        this.activeModeForMs = 0;
        this.isCurrentlyRunning = false;
        this.cycleLengthMs = 1000;
    }
    setState(state) {
        if (!this.state) {
            this.state = state;
        }
        else {
            Object.assign(this.state, state);
        }
    }
    hasRunner(name) {
        return !!this.runners[name];
    }
    addRunner(name, fun, activeModeRefreshIntervalMs, bgModeRefreshIntervalMs) {
        if (name in this.runners) {
            return;
        }
        this.runners[name] = {
            fun,
            activeModeRefreshIntervalMs,
            bgModeRefreshIntervalMs,
        };
        __1.logger.debug(`Monitor runner added: ${name}`);
    }
    removeRunner(name) {
        if (!(name in this.runners)) {
            return;
        }
        delete this.runners[name];
        __1.logger.debug(`Monitor runner removed: ${name}`);
    }
    setActiveModeFor(ms) {
        this.activeModeForMs = ms;
        this.activeModeSince = Date.now();
    }
    async start() {
        while (true) {
            const startOn = Date.now();
            await this.run();
            const endOn = Date.now();
            const sleepMs = Math.max(0, this.cycleLengthMs - (endOn - startOn));
            await new Promise((resolve) => setTimeout(resolve, sleepMs));
        }
    }
    async run(force) {
        if (this.isCurrentlyRunning || !this.state) {
            return;
        }
        const state = this.state;
        this.isCurrentlyRunning = true;
        const promises = [];
        for (const runnerName in this.runners) {
            const runner = this.runners[runnerName];
            const activeMode = this.activeModeSince && this.activeModeSince + this.activeModeForMs > Date.now();
            const refreshIntervalMs = activeMode
                ? runner.activeModeRefreshIntervalMs
                : runner.bgModeRefreshIntervalMs;
            if (!refreshIntervalMs) {
                continue;
            }
            const shouldRun = force || !runner.lastRunOn || runner.lastRunOn + refreshIntervalMs < Date.now();
            if (!shouldRun) {
                continue;
            }
            runner.lastRunOn = Date.now();
            promises.push((async () => {
                __1.logger.debug(`Monitor started: ${runnerName}`);
                const startTime = Date.now();
                const res = await runner.fun(state, this.bus);
                const endTime = Date.now();
                __1.logger.debug(`Monitor ended: ${runnerName}`);
                const duration = endTime - startTime;
                if (duration > 1000) {
                    __1.logger.warn(`Monitor ${runnerName} took ${duration}ms to execute.`);
                }
                return res;
            })());
        }
        const results = await Promise.all(promises);
        const stateChanges = Object.assign({}, ...results);
        if (Object.keys(stateChanges).length > 0) {
            __1.logger.trace(`Monitor state changes: ${JSON.stringify(stateChanges)}`);
        }
        await this.bus.setState(stateChanges);
        this.isCurrentlyRunning = false;
    }
}
exports.MonitorRunner = MonitorRunner;
//# sourceMappingURL=runner.js.map