"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkForUpgrades = void 0;
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const __1 = require("..");
async function checkForUpgrades(state, bus) {
    const scheduledUpgradeToTag = (await bus.getState(["release:scheduledUpgradeToTag"]))["release:scheduledUpgradeToTag"];
    if (!scheduledUpgradeToTag) {
        __1.logger.trace("No scheduled upgrade.");
        return {};
    }
    __1.logger.debug(`Scheduled upgrade found: ${scheduledUpgradeToTag}`);
    // checking if update is allowed by schedule
    // TODO_FUTURE: encapsulate and test
    const [fromHour, fromMinute] = state.settings.updateTimeRange.from
        .split(":")
        .map((v) => Number(v));
    const [tillHour, tillMinute] = state.settings.updateTimeRange.till
        .split(":")
        .map((v) => Number(v));
    const now = new Date();
    const nowHour = now.getHours();
    const nowMinute = now.getMinutes();
    let updateIsAllowed = false;
    if (tillHour > fromHour || (tillHour === fromHour && tillMinute >= fromMinute)) {
        updateIsAllowed =
            (nowHour > fromHour || (nowHour === fromHour && nowMinute >= fromMinute)) &&
                (nowHour < tillHour || (nowHour === tillHour && nowMinute < tillMinute));
    }
    else {
        updateIsAllowed =
            nowHour > fromHour ||
                (nowHour === fromHour && nowMinute >= fromMinute) ||
                nowHour < tillHour ||
                (nowHour === tillHour && nowMinute < tillMinute);
    }
    if (!updateIsAllowed) {
        __1.logger.debug("Upgrade not allowed by schedule");
        return {};
    }
    __1.logger.warn(`Running scheduled upgrade to ${scheduledUpgradeToTag}`);
    await bus.sendMsg(new opcb_ts_shared_1.redisBus.Upgrade(scheduledUpgradeToTag));
    return {};
}
exports.checkForUpgrades = checkForUpgrades;
//# sourceMappingURL=upgrade.js.map