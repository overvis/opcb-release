"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateConnection = exports.getConnectionParams = exports.ensureConnectionIsDown = exports.ensureConnectionIsUp = exports.connectionIsUp = exports.connectionExists = exports.ensureDeviceConnected = exports.ensureDeviceDisconnected = exports.getDevicesStatuses = exports.ensureElanIsConfigured = void 0;
const __1 = require("..");
const exec_1 = require("../exec");
async function ensureElanIsConfigured(config, vpnMotherlandServerIp) {
    __1.logger.debug("Ensuring elan is configured...");
    if (!config.networkInterfaceName) {
        __1.logger.info("No network interface name specified: disabling opcb-elan connection.");
        await ensureConnectionIsDown("opcb-elan");
        return;
    }
    // check if connection exists if not, create it
    if (!(await connectionExists("opcb-elan"))) {
        __1.logger.warn("No opcb-elan connection exists. Creating...");
        await (0, exec_1.exec)("nmcli", [
            "connection",
            "add",
            "con-name",
            "opcb-elan",
            "ifname",
            config.networkInterfaceName,
            "type",
            "ethernet",
        ]);
    }
    // get current connection settings and find changes
    const options = await getConnectionParams("opcb-elan");
    const changes = {};
    if (options["connection.interface-name"] !== config.networkInterfaceName) {
        changes["connection.interface-name"] = config.networkInterfaceName;
    }
    if (options["ipv6.method"] !== "ignore") {
        changes["ipv6.method"] = "ignore";
    }
    if (options["connection.autoconnect"] !== "yes") {
        changes["connection.autoconnect"] = "TRUE";
    }
    if (config.dhcpIsEnabled) {
        if (options["ipv4.method"] !== "auto") {
            changes["ipv4.method"] = "auto";
        }
        if (options["ipv4.addresses"] !== "") {
            changes["ipv4.addresses"] = "";
        }
        if (options["ipv4.gateway"] !== "") {
            changes["ipv4.gateway"] = "";
        }
        if (options["ipv4.dns"] !== "") {
            changes["ipv4.dns"] = "";
        }
    }
    else {
        if (options["ipv4.method"] !== "manual") {
            changes["ipv4.method"] = "manual";
        }
        // TODO_FUTURE: mask
        if (options["ipv4.addresses"] !== config.staticIpSettings.ipAddress + "/24") {
            changes["ipv4.addresses"] = config.staticIpSettings.ipAddress + "/24";
        }
        if (options["ipv4.gateway"] !== config.staticIpSettings.gateway) {
            changes["ipv4.gateway"] = config.staticIpSettings.gateway;
        }
        const dns = [
            config.staticIpSettings.primaryDns,
            config.staticIpSettings.secondaryDns,
        ].join(",");
        if (options["ipv4.dns"] !== dns) {
            changes["ipv4.dns"] = dns;
        }
    }
    await updateConnection("opcb-elan", config.networkInterfaceName, changes, vpnMotherlandServerIp);
}
exports.ensureElanIsConfigured = ensureElanIsConfigured;
async function getDevicesStatuses() {
    const out = await (0, exec_1.exec)("nmcli", ["-f", "DEVICE,STATE", "-t", "device", "status"]);
    const devices = Object.fromEntries(out
        .split("\n")
        .filter((line) => line !== "")
        .map((line) => line.trim().split(":")));
    return devices;
}
exports.getDevicesStatuses = getDevicesStatuses;
async function ensureDeviceDisconnected(iface) {
    __1.logger.debug(`Ensuring device ${iface} is disconnected...`);
    const devices = await getDevicesStatuses();
    if (devices[iface] === "connected") {
        __1.logger.info(`Diconnecting ${iface} device...`);
        await (0, exec_1.exec)("nmcli", ["device", "disconnect", iface]);
    }
}
exports.ensureDeviceDisconnected = ensureDeviceDisconnected;
async function ensureDeviceConnected(iface) {
    __1.logger.debug(`Ensuring device ${iface} is connected...`);
    const devices = await getDevicesStatuses();
    if (devices[iface] !== "connected") {
        __1.logger.info(`Connecting ${iface} device...`);
        await (0, exec_1.exec)("nmcli", ["device", "connect", iface]);
    }
}
exports.ensureDeviceConnected = ensureDeviceConnected;
async function connectionExists(name) {
    const out = await (0, exec_1.exec)("nmcli", ["-t", "-f", "NAME", "connection", "show"]);
    const connections = out
        .split("\n")
        .filter((line) => line !== "")
        .map((line) => line.trim());
    return connections.includes(name);
}
exports.connectionExists = connectionExists;
async function connectionIsUp(name) {
    const [out, code] = await (0, exec_1.execCmd)("nmcli", [
        "-t",
        "-f",
        "GENERAL.STATE",
        "connection",
        "show",
        name,
    ]);
    if (code !== 0) {
        return false;
    }
    const o = Object.fromEntries(out
        .split("\n")
        .filter((line) => line !== "")
        .map((line) => line
        .trim()
        .split(":")
        .map((v) => v.trim())));
    return o["GENERAL.STATE"] === "activated";
}
exports.connectionIsUp = connectionIsUp;
async function ensureConnectionIsUp(name) {
    __1.logger.debug(`Ensuring connection ${name} is up...`);
    if (!(await connectionIsUp(name))) {
        __1.logger.info(`Activating connection ${name}...`);
        const [out, exitCode, err] = await (0, exec_1.execCmd)("nmcli", ["connection", "up", name]);
        if (exitCode) {
            __1.logger.error(`Failed to activate connection ${name} (code ${exitCode}):\n${out}\n${err}`);
        }
    }
}
exports.ensureConnectionIsUp = ensureConnectionIsUp;
async function ensureConnectionIsDown(name) {
    __1.logger.debug(`Ensuring connection ${name} is down...`);
    if (await connectionIsUp(name)) {
        __1.logger.info(`Deactivating connection ${name}...`);
        await (0, exec_1.exec)("nmcli", ["connection", "down", name]);
    }
}
exports.ensureConnectionIsDown = ensureConnectionIsDown;
async function getConnectionParams(name) {
    const out = await (0, exec_1.exec)("nmcli", ["--show-secrets", "-t", "connection", "show", name]);
    const options = Object.fromEntries(out
        .split("\n")
        .filter((line) => line !== "")
        .map((line) => line
        .trim()
        .split(":")
        .map((v) => v.trim())));
    return options;
}
exports.getConnectionParams = getConnectionParams;
async function updateConnection(name, iface, changes, vpnMotherlandServerIp, waitSec = 10) {
    // if there are changes, update the connection
    if (Object.keys(changes).length < 1) {
        __1.logger.debug(`No config changes for ${name}.`);
        await ensureConnectionIsUp(name);
        return;
    }
    __1.logger.info(`${name} connection configuration changed. Updating...`);
    await (0, exec_1.exec)("nmcli", ["connection", "modify", name, ...Object.entries(changes).flat()]);
    // disconnect-connect if needed
    await (0, exec_1.exec)("nmcli", ["connection", "reload"]);
    await ensureDeviceDisconnected(iface);
    await (0, exec_1.exec)("nmcli", ["device", "set", iface, "autoconnect", "yes", "managed", "yes"]);
    // waiting for 1 second before proceeding to let linux up/down scripts to execute
    await new Promise((resolve) => setTimeout(resolve, 1000));
    __1.logger.info(`Connecting ${iface} device...`);
    const [_out, exitCode] = await (0, exec_1.execCmd)("nmcli", [
        "--wait",
        waitSec.toString(),
        "connection",
        "up",
        name,
    ]);
    if (exitCode !== 0) {
        __1.logger.warn(`"nmcli connection up" exited with code ${exitCode || "null"}`);
    }
    // check wireguard status
    if (await (0, exec_1.serviceIsActive)("wg-quick@wg0")) {
        const pingRes = await (0, exec_1.ping)(vpnMotherlandServerIp);
        if (pingRes === undefined) {
            __1.logger.info("VPN is not connected. Restarting...");
            await (0, exec_1.exec)("systemctl", ["restart", "wg-quick@wg0"]);
        }
    }
}
exports.updateConnection = updateConnection;
//# sourceMappingURL=elan.js.map