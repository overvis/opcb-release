"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureGsmIsConfigured = void 0;
const __1 = require("..");
const exec_1 = require("../exec");
const elan_1 = require("./elan");
async function ensureGsmIsConfigured(config) {
    __1.logger.debug("Ensuring gsm is configured...");
    if (!config.manageGsm) {
        __1.logger.info("No gsm interface name is specified. Ensuring that gsm is disabled.");
        await (0, elan_1.ensureConnectionIsDown)("opcb-gsm");
        return;
    }
    const out = await (0, exec_1.exec)("nmcli", ["-t", "radio", "wwan"]);
    if (out.trim() !== "enabled") {
        __1.logger.info("Wwan radio is disabled. Enabling...");
        await (0, exec_1.exec)("nmcli", ["radio", "wwan", "on"]);
    }
    // create connection if it doesn't exist
    if (!(await (0, elan_1.connectionExists)("opcb-gsm"))) {
        __1.logger.warn("No opcb-gsm connection exists. Creating...");
        await (0, exec_1.exec)("nmcli", [
            "connection",
            "add",
            "con-name",
            "opcb-gsm",
            "ifname",
            "",
            "type",
            "gsm",
        ]);
    }
    // get current connection settings and find changes
    const options = await (0, elan_1.getConnectionParams)("opcb-gsm");
    const changes = {};
    if (options["connection.interface-name"] !== "") {
        changes["connection.interface-name"] = "";
    }
    if (options["ipv6.method"] !== "ignore") {
        changes["ipv6.method"] = "ignore";
    }
    if (options["connection.autoconnect"] !== "yes") {
        changes["connection.autoconnect"] = "TRUE";
    }
    if (options["ipv4.method"] !== "auto") {
        changes["ipv4.method"] = "auto";
    }
    if (options["ipv4.addresses"] !== "") {
        changes["ipv4.addresses"] = "";
    }
    if (options["ipv4.gateway"] !== "") {
        changes["ipv4.gateway"] = "";
    }
    if (options["ipv4.dns"] !== "") {
        changes["ipv4.dns"] = "";
    }
    if (options["ipv4.route-metric"] !== "3000") {
        changes["ipv4.route-metric"] = "3000";
    }
    if (options["gsm.apn"] !== config.apn) {
        changes["gsm.apn"] = config.apn;
    }
    if (options["gsm.username"] !== config.apnUserName) {
        changes["gsm.username"] = config.apnUserName;
    }
    if (options["gsm.password"] !== config.apnPassword) {
        changes["gsm.password"] = config.apnPassword;
    }
    if (options["gsm.number"] !== config.operatorPhoneNumber) {
        changes["gsm.number"] = config.operatorPhoneNumber;
    }
    if (options["gsm.pin"] !== config.simPinCode) {
        changes["gsm.pin"] = config.simPinCode;
    }
    await updateGsmConnection("opcb-gsm", changes);
}
exports.ensureGsmIsConfigured = ensureGsmIsConfigured;
async function updateGsmConnection(name, changes, waitSec = 10) {
    // if there are changes, update the connection
    if (Object.keys(changes).length < 1) {
        __1.logger.debug(`No config changes for ${name}.`);
        await (0, elan_1.ensureConnectionIsUp)(name);
        return;
    }
    __1.logger.info(`${name} connection configuration changed. Updating...`);
    await (0, exec_1.exec)("nmcli", ["connection", "modify", name, ...Object.entries(changes).flat()]);
    // disconnect-connect if needed
    await (0, exec_1.exec)("nmcli", ["connection", "reload"]);
    // Connecting with timeout
    __1.logger.info(`Connecting up ${name}...`);
    const [_out, exitCode] = await (0, exec_1.execCmd)("nmcli", [
        "--wait",
        waitSec.toString(),
        "connection",
        "up",
        name,
    ]);
    if (exitCode !== 0) {
        __1.logger.warn(`"nmcli connection up ${name}" exited with code ${exitCode || "null"}`);
    }
}
//# sourceMappingURL=gsm.js.map