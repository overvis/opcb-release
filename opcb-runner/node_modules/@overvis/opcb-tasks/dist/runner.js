"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeRunnerCallbacks = exports.TasksRunner = void 0;
const worker_threads_1 = require("worker_threads");
const _1 = require(".");
class TasksRunner {
    constructor(workerRequisites, cb) {
        this.workerRequisites = workerRequisites;
        this.cb = cb;
        this.tasks = new Map();
    }
    registerTask(task) {
        _1.logger.info(`Registering task #${task.id} (${task.filepath})...`);
        if (this.tasks.has(task.id)) {
            throw new Error(`Task with id ${task.id} is already registered.`);
        }
        this.tasks.set(task.id, { descriptior: task, restartScheduled: false, failed: false });
        if (task.autorunOnStartup) {
            this.runTask(task.id);
        }
        this.updateStats();
    }
    async unregisterTask(id) {
        _1.logger.debug(`Requested to unregister task #${id}...`);
        const task = this.tasks.get(id);
        if (!task) {
            throw new Error(`No task with id ${id} was registered.`);
        }
        _1.logger.info(`Unregistering task #${id} (${task.descriptior.filepath})...`);
        if (task.currentRun) {
            _1.logger.info(`Task #${id} (${task.descriptior.filepath}) is running. Stopping...`);
            await this.stopTask(id);
        }
        this.tasks.delete(id);
        this.updateStats();
    }
    listTaskIds() {
        return [...this.tasks.keys()];
    }
    updateTask(id, descriptor) {
        _1.logger.info(`Updating task #${id}...`);
        const task = this.tasks.get(id);
        if (!task) {
            throw new Error(`No task with id ${id} was registered.`);
        }
        const desc = task.descriptior;
        desc.name = descriptor.name;
        desc.description = descriptor.description;
        desc.autorunOnStartup = descriptor.autorunOnStartup;
        desc.logToStdout = descriptor.logToStdout;
        desc.restart = descriptor.restart;
        desc.restartDelayMs = descriptor.restartDelayMs;
        desc.userJson = descriptor.userJson;
    }
    runTask(id) {
        _1.logger.debug(`Requested to run task #${id}...`);
        const task = this.tasks.get(id);
        if (!task) {
            throw new Error(`No task with id ${id} was registered.`);
        }
        if (task.currentRun) {
            // throw new Error(`Task #${id} (${task.descriptior.filepath}) is already running.`);
            return;
        }
        const filepath = task.descriptior.filepath;
        _1.logger.info(`Running task #${id} (${filepath})...`);
        const workerData = {
            taskId: id,
            userJson: task.descriptior.userJson,
            ...this.workerRequisites,
        };
        const worker = new worker_threads_1.Worker(filepath, {
            name: `#${id} - ${filepath}`,
            stdin: true,
            stdout: true,
            stderr: true,
            workerData,
        });
        const startedOn = new Date();
        const currentRun = { startedOn, worker, online: false, log: "", stopped: false };
        task.currentRun = currentRun;
        task.failed = false;
        worker.on("online", () => {
            currentRun.online = true;
            _1.logger.info(`Task #${id} (${filepath}) is online.`);
        });
        worker.on("exit", this.makeTaskExitProcessor(task, startedOn));
        worker.on("error", (error) => {
            _1.logger.error(error, `Task #${id} (${filepath}) encountered an error.`);
            currentRun.error = error;
            task.failed = true;
        });
        worker.stdout.on("data", (data) => {
            const str = data.toString().trim();
            if (task.descriptior.logToStdout) {
                _1.logger.info(`#${task.descriptior.id} : ` + str);
            }
            currentRun.log += str + "\n";
            this.cb.logTaskOutput(task.descriptior, false, str).catch((err) => {
                const message = `Error while trying to log for task: ${err}`;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                _1.logger.warn({ err, str }, message);
            });
        });
        worker.stderr.on("data", (data) => {
            const str = data.toString().trim();
            if (task.descriptior.logToStdout) {
                _1.logger.warn(`#${task.descriptior.id} : ` + str);
            }
            currentRun.log += str + "\n";
            this.cb.logTaskOutput(task.descriptior, true, str).catch((err) => {
                const message = `Error while trying to log for task: ${err}`;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                _1.logger.warn({ err, str }, message);
            });
        });
        const runId = this.cb.registerRunStart(task.descriptior, startedOn);
        currentRun.runId = runId;
        this.updateStats();
    }
    async stopTask(id) {
        _1.logger.debug(`Requested to stop task #${id}...`);
        const task = this.tasks.get(id);
        if (!task) {
            throw new Error(`No task with id ${id} was registered.`);
        }
        const filepath = task.descriptior.filepath;
        if (!task.currentRun) {
            // throw new Error(`Task #${id} (${filepath}) is not running.`);
            return;
        }
        _1.logger.info(`Stopping task #${id} (${filepath})...`);
        task.currentRun.stopped = true;
        await task.currentRun.worker.terminate();
        task.currentRun = undefined;
        task.restartScheduled = false;
        this.updateStats();
    }
    restartTask(id) {
        const task = this.tasks.get(id);
        if (!task) {
            _1.logger.debug(`Task #${id} was removed during restart delay.`);
            return;
        }
        const filepath = task.descriptior.filepath;
        if (task.currentRun) {
            _1.logger.debug(`Task #${id} (${filepath}) started during restart delay.`);
            return;
        }
        if (!task.restartScheduled) {
            _1.logger.debug(`Restart of task #${id} (${filepath}) was canceled during delay.`);
            return;
        }
        _1.logger.info(`Restarting task #${id} (${filepath})...`);
        this.runTask(id);
    }
    makeTaskExitProcessor(task, _startedOn) {
        const id = task.descriptior.id;
        const filepath = task.descriptior.filepath;
        return (code) => {
            var _a, _b, _c, _d;
            if (code !== 0) {
                _1.logger.warn(`Task #${id} (${filepath}) finished with non-zero exit code ${code}.`);
            }
            let error = (_a = task.currentRun) === null || _a === void 0 ? void 0 : _a.error;
            if (!error && ((_b = task.currentRun) === null || _b === void 0 ? void 0 : _b.stopped)) {
                error = new Error("Task was terminated by user.");
            }
            else if (!error && code !== 0) {
                error = new Error(`Finished with non-zero exit code ${code}.`);
            }
            const finishedOn = new Date();
            // const duration = finishedOn.getTime() - startedOn.getTime();
            this.cb.registerRunFinish(task.descriptior, finishedOn, (_c = task.currentRun) === null || _c === void 0 ? void 0 : _c.runId, (_d = task.currentRun) === null || _d === void 0 ? void 0 : _d.log, error);
            task.currentRun = undefined;
            this.updateStats();
            if (task.descriptior.restart === "always" ||
                (task.descriptior.restart === "on-success" && !error)) {
                task.restartScheduled = true;
                setTimeout(() => this.restartTask(id), task.descriptior.restartDelayMs);
            }
        };
    }
    updateStats() {
        const total = this.tasks.size;
        const running = [...this.tasks.values()].filter((t) => t.currentRun).length;
        const failed = [...this.tasks.values()].filter((t) => t.failed).length;
        this.cb.updateRunnerStats(total, running, failed).catch((err) => {
            _1.logger.error(err, "Error while updating runner stats.");
        });
    }
}
exports.TasksRunner = TasksRunner;
function makeRunnerCallbacks(db, memdb, redisClient) {
    const STATS_LOG_TASK_RUN_START_SQL = db.prepare(`
        update task_stats
        set
            runs_num = runs_num + 1,
            last_run_start_on = @time
        where task_id = @taskId`);
    const STATS_LOG_TASK_RUN_ERROR_SQL = db.prepare(`
        update task_stats
        set
            last_run_finish_on = @time,
            last_run_error = @error,
            errors_num = errors_num + 1
        where task_id = @taskId`);
    const STATS_LOG_TASK_RUN_SUCCESS_SQL = db.prepare(`
        update task_stats
        set
            last_run_finish_on = @time
        where task_id = @taskId`);
    const CREATE_TASK_RUN_SQL = memdb.prepare(`
        insert into task_runs (task_id, started_on, user_json)
        values (@taskId, @time, @userJson)
        returning id`);
    const FINISH_TASK_RUN_SQL = memdb.prepare(`
        update task_runs
        set
            finished_on = @time,
            log = @log,
            error = @error
        where id = @runId`);
    return {
        registerRunStart: (task, date) => {
            var _a;
            STATS_LOG_TASK_RUN_START_SQL.run({
                time: date.getTime() / 1000,
                taskId: task.id,
            });
            const runId = CREATE_TASK_RUN_SQL.get({
                taskId: task.id,
                time: date.getTime() / 1000,
                userJson: (_a = task.userJson) !== null && _a !== void 0 ? _a : null,
            }).id;
            return runId;
        },
        registerRunFinish: (task, date, runId, log, error) => {
            var _a;
            if (error) {
                STATS_LOG_TASK_RUN_ERROR_SQL.run({
                    time: date.getTime() / 1000,
                    taskId: task.id,
                    error: error.message,
                });
            }
            else {
                STATS_LOG_TASK_RUN_SUCCESS_SQL.run({
                    time: date.getTime() / 1000,
                    taskId: task.id,
                });
            }
            if (runId) {
                FINISH_TASK_RUN_SQL.run({
                    runId,
                    time: date.getTime() / 1000,
                    log: log !== null && log !== void 0 ? log : null,
                    error: (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : null,
                });
            }
        },
        logTaskOutput: async (task, isStdErr, text) => {
            const level = isStdErr ? "error" : "info";
            await redisClient.writeTaskLogRec(task.id, level, text);
        },
        updateRunnerStats: async (total, running, failed) => {
            await redisClient.setState({
                "tasks:totalTasksNum": total,
                "tasks:runningTasksNum": running,
                "tasks:failedTasksNum": failed,
            });
        },
    };
}
exports.makeRunnerCallbacks = makeRunnerCallbacks;
//# sourceMappingURL=runner.js.map