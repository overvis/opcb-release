"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAPPERS = void 0;
function id(v) {
    return v;
}
function uint16ToBool(v) {
    return v !== 0;
}
function boolToUint16(v) {
    return v ? 1 : 0;
}
function uint16ToUint8(v) {
    return v & 0xff;
}
function uint16ToInt8(v) {
    var u = uint16ToUint8(v);
    return u > 0x7f ? u - 0xff : u;
}
function uint16ToInt16(v) {
    return v > 0x7fff ? v - 0xffff : v;
}
function uint16sToUint32(v) {
    return new DataView(new Uint16Array(v).buffer).getUint32(0, true);
}
function uint16sToInt32(v) {
    return new DataView(new Uint16Array(v).buffer).getInt32(0, true);
}
function uint16sToFloat(v) {
    return new DataView(new Uint16Array(v).buffer).getFloat32(0, true);
}
function uint16sToDouble(v) {
    return new DataView(new Uint16Array(v).buffer).getFloat64(0, true);
}
function uint16sToUtf8String(v) {
    return String.fromCharCode.apply(String, v.filter(function (d) { return d !== 0; }));
}
function uint16sToIPv4(v) {
    return v.join(".");
}
function uint16sToMAC(v) {
    return v.map(function (d) { return d.toString(16).padStart(2, "0"); }).join(":");
}
function uint16sToHexWordsString(v) {
    return v.map(function (d) { return d.toString(16).padStart(4, "0"); }).join(" ");
}
function uint16sToHexBytesString(v) {
    return v.map(function (d) { return (d & 0xff).toString(16).padStart(2, "0"); }).join(" ");
}
exports.MAPPERS = {
    uint16: {
        bool: uint16ToBool,
        uint8: uint16ToUint8,
        int8: uint16ToInt8,
        uint16: id,
        int16: uint16ToInt16,
    },
    uint16s: {
        int32: uint16sToInt32,
        uint32: uint16sToUint32,
        float: uint16sToFloat,
        double: uint16sToDouble,
        utf8str: uint16sToUtf8String,
        ipv4: uint16sToIPv4,
        mac: uint16sToMAC,
        hexWordsStr: uint16sToHexWordsString,
        hexBytesStr: uint16sToHexBytesString,
    },
    bool: {
        uint16: boolToUint16,
    },
};
//# sourceMappingURL=mappers.js.map