"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFromTable = exports.prefixKeys = void 0;
var tslib_1 = require("tslib");
var types_1 = require("../types");
function prefixKeys(dict, prefix) {
    return [
        Object.fromEntries(Object.entries(dict)
            .filter(function (v) { return v[1] !== null && v[1] !== undefined; })
            .map(function (v) { return [prefix + v[0], v[1]]; })),
        Object.entries(dict)
            .filter(function (v) { return v[1] === null || v[1] === undefined; })
            .map(function (v) { return prefix + v[0]; }),
    ];
}
exports.prefixKeys = prefixKeys;
function readFromTable(redis, prefix, keys) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var prefixedKeys, newPrefixedKeys, _i, prefixedKeys_1, key, unfoldedKeys, result, values, i, _a, keys_1, key;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!!keys) return [3 /*break*/, 2];
                    return [4 /*yield*/, redis.keys(prefix + "*")];
                case 1:
                    prefixedKeys = _b.sent();
                    return [3 /*break*/, 3];
                case 2:
                    prefixedKeys = keys.map(function (v) { return prefix + v; });
                    _b.label = 3;
                case 3:
                    newPrefixedKeys = [];
                    _i = 0, prefixedKeys_1 = prefixedKeys;
                    _b.label = 4;
                case 4:
                    if (!(_i < prefixedKeys_1.length)) return [3 /*break*/, 8];
                    key = prefixedKeys_1[_i];
                    if (!key.includes("*")) return [3 /*break*/, 6];
                    return [4 /*yield*/, redis.keys(key)];
                case 5:
                    unfoldedKeys = _b.sent();
                    newPrefixedKeys.push.apply(newPrefixedKeys, unfoldedKeys);
                    return [3 /*break*/, 7];
                case 6:
                    newPrefixedKeys.push(key);
                    _b.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 4];
                case 8:
                    prefixedKeys = newPrefixedKeys;
                    result = {};
                    if (prefixedKeys.length < 1) {
                        return [2 /*return*/, result];
                    }
                    return [4 /*yield*/, redis.mget(prefixedKeys)];
                case 9:
                    values = _b.sent();
                    for (i = 0; i < prefixedKeys.length; i++) {
                        result[prefixedKeys[i].slice(prefix.length)] = (0, types_1.notNull)(values[i]);
                    }
                    // TODO_FUTURE: document and test
                    if (keys) {
                        for (_a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
                            key = keys_1[_a];
                            if (!(key in result) && !key.includes("*")) {
                                result[key] = undefined;
                            }
                        }
                    }
                    return [2 /*return*/, result];
            }
        });
    });
}
exports.readFromTable = readFromTable;
//# sourceMappingURL=table.js.map