"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MODBUS_TCP_SERVER_SCHEMA = void 0;
var typebox_1 = require("@sinclair/typebox");
var modbus_mappers_1 = require("../modbus-mappers");
exports.MODBUS_TCP_SERVER_SCHEMA = typebox_1.Type.Object({
    interface: typebox_1.Type.Union([
        typebox_1.Type.Literal("disabled"),
        typebox_1.Type.Literal("any"),
        typebox_1.Type.Literal("lo"),
        typebox_1.Type.Literal("elan"),
        typebox_1.Type.Literal("wlan"),
    ], {
        name: "Network interface",
        mapper: new modbus_mappers_1.MAPPERS.Enum(1600, { disabled: 0, any: 1, lo: 2, elan: 3, wlan: 4 }),
        description: "Network interface to listen for Modbus TCP requests.\ndisabled - Modbus TCP server is disabled completely.\nany - Modbus TCP server is listening on all interfaces.\nlo - Modbus TCP server is listening on loopback interface.\nelan - Modbus TCP server is listening on Ethernet LAN interface.\nwlan - Modbus TCP server is listening on Wi-Fi LAN interface.",
        default: "any",
        group: "TCP server",
    }),
    port: typebox_1.Type.Integer({
        name: "Modbus TCP server port",
        mapper: new modbus_mappers_1.MAPPERS.U16(1601),
        minimum: 1,
        maximum: 65535,
        description: "Modbus TCP server port.",
        default: 502,
        group: "TCP server",
    }),
    maxClients: typebox_1.Type.Integer({
        name: "Maximum number of Modbus TCP client connections",
        mapper: new modbus_mappers_1.MAPPERS.U8(1602),
        minimum: 1,
        maximum: 20,
        description: "Maximum number of Modbus TCP client connections.",
        default: 4,
        group: "TCP server",
    }),
    clientAliveTimeoutSec: typebox_1.Type.Integer({
        name: "Client alive timeout",
        mapper: new modbus_mappers_1.MAPPERS.U16(1603),
        minimum: 15,
        maximum: 3600,
        description: "Time (in seconds) without data transfer, after which the client is considered disconnected.",
        default: 60,
        group: "TCP server",
        unit: "s",
    }),
    responseTimeoutMs: typebox_1.Type.Integer({
        name: "Response timeout",
        mapper: new modbus_mappers_1.MAPPERS.U16(1604),
        minimum: 1,
        maximum: 60000,
        description: "Response timeout in milliseconds.",
        default: 1500,
        group: "TCP server",
        unit: "ms",
    }),
    parallelRequestsNum: typebox_1.Type.Integer({
        name: "Maximum number of simultaneously processed requests from one client",
        mapper: new modbus_mappers_1.MAPPERS.U8(1605),
        minimum: 1,
        maximum: 20,
        description: "Maximum number of simultaneously processed requests from one client.\n1 - each request waits until the previous one is finished.\nOther values allow for responses to be sent in groups.",
        default: 1,
        group: "TCP server",
    }),
    portOpenRetryPeriodSec: typebox_1.Type.Integer({
        name: "Port open retry period",
        mapper: new modbus_mappers_1.MAPPERS.U16(1606),
        minimum: 1,
        maximum: 600,
        description: "Time (in seconds) to wait befory retrying open port for listening if it is not available.",
        default: 5,
        group: "TCP server",
        unit: "s",
    }),
    broadcastIsEnabled: typebox_1.Type.Boolean({
        name: "Enable broadcast requests",
        mapper: new modbus_mappers_1.MAPPERS.Bool(1607),
        description: "Enable broadcast Modbus TCP requests.",
        default: false,
        group: "TCP server",
    }),
}, {
    description: "Modbus TCP server configuration.",
    additionalProperties: false,
    default: {},
});
//# sourceMappingURL=modbus-tcp-server.schema.js.map