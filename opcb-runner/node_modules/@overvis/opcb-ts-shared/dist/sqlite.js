"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateDb = exports.initMemDb = exports.connectSqlite = void 0;
var tslib_1 = require("tslib");
var better_sqlite3_1 = tslib_1.__importDefault(require("better-sqlite3"));
var fs = tslib_1.__importStar(require("fs"));
var crypto = tslib_1.__importStar(require("crypto"));
function connectSqlite(path, libDir) {
    var db = (0, better_sqlite3_1.default)(path, {
        nativeBinding: (libDir || __dirname + "/../sqlite/") + "/better_sqlite3.node",
    });
    db.loadExtension((libDir || __dirname + "/../sqlite/") + "/uuid.so");
    return db;
}
exports.connectSqlite = connectSqlite;
function initMemDb(path, libDir, unlink) {
    if (unlink === void 0) { unlink = true; }
    if (unlink) {
        try {
            fs.unlinkSync(path);
        }
        catch (e) { }
    }
    var db = connectSqlite(path, libDir);
    db.exec("pragma journal_mode=wal");
    var memDbSchema = fs.readFileSync(__dirname + "/../init-memdb.sql", "utf-8");
    db.exec(memDbSchema);
}
exports.initMemDb = initMemDb;
function migrateDb(path, logger, libDir) {
    var db = connectSqlite(path, libDir);
    db.exec("pragma journal_mode=wal");
    var dbMigrationsDir = __dirname + "/../db-migrations";
    // check if migrations table exists
    var res1 = db
        .prepare("select count(*) as \"count\" from sqlite_master where type='table' and name='applied_migrations';")
        .get();
    if (!(res1 === null || res1 === void 0 ? void 0 : res1.count)) {
        migrateFrom(db, dbMigrationsDir, undefined, logger);
        return;
    }
    var res = db
        .prepare("select id, file_name, file_hash from applied_migrations order by id;")
        .all();
    var lastId;
    var appliedMigrations = {};
    for (var _i = 0, res_1 = res; _i < res_1.length; _i++) {
        var r = res_1[_i];
        appliedMigrations[r.id] = { filename: r.file_name, hash: r.file_hash };
        if (lastId === undefined || r.id > lastId) {
            lastId = r.id;
        }
    }
    // check applied migrations
    var migrations = getMigrations(dbMigrationsDir)[0];
    if (lastId !== undefined) {
        for (var i = 0; i <= lastId; i++) {
            var applied = appliedMigrations[i];
            var migration = migrations[i];
            if (!migration) {
                logger.error("Missing migration #".concat(i, ". Aborting migration process."));
                return;
            }
            if (!applied) {
                logger.error("Gap in applied migrations, missing (".concat(migration.filename, "). ") +
                    "Aborting migration process.");
                return;
            }
            if (applied.filename !== migration.filename) {
                logger.error("Incorrect applied migration name " +
                    "(\"".concat(applied.filename, "\" should be \"").concat(migration.filename, "\"). ") +
                    "Aborting migration process.");
                return;
            }
            if (applied.hash !== migration.hash) {
                logger.error("Incorrect applied migration hash " +
                    "(\"".concat(applied.filename, "\" hash should be \"").concat(migration.hash, "\"). ") +
                    "Aborting migration process.");
                return;
            }
        }
    }
    if (lastId === undefined) {
        migrateFrom(db, dbMigrationsDir, undefined, logger);
        return;
    }
    migrateFrom(db, dbMigrationsDir, lastId, logger);
}
exports.migrateDb = migrateDb;
function getMigrations(dbMigrationsDir) {
    var migrationFiles = fs.readdirSync(dbMigrationsDir).filter(function (f) { return !f.startsWith("."); });
    var migrations = [];
    var latestId;
    for (var _i = 0, migrationFiles_1 = migrationFiles; _i < migrationFiles_1.length; _i++) {
        var filename = migrationFiles_1[_i];
        var _a = filename.split("."), idStr = _a[0], name = _a[1], type = _a[2], ext = _a[3];
        var id = Number(idStr);
        if (type !== "up" || ext !== "sql")
            continue;
        var sql = fs.readFileSync(dbMigrationsDir + "/" + filename, "utf8");
        var hash = crypto.createHash("sha256").update(sql).digest("hex");
        migrations[id] = {
            id: id,
            name: name,
            filename: filename,
            sql: sql,
            hash: hash,
        };
        if (latestId === undefined || latestId < Number(id)) {
            latestId = Number(id);
        }
    }
    return [migrations, latestId];
}
function migrateFrom(db, dbMigrationsDir, fromId, logger) {
    var _a = getMigrations(dbMigrationsDir), migrations = _a[0], latestId = _a[1];
    if (latestId === undefined || (fromId !== undefined && fromId >= latestId))
        return;
    logger.warn("Migrating database from ".concat(fromId || "clean state", " to ").concat(latestId, "..."));
    var startId = fromId === undefined ? 0 : fromId + 1;
    for (var i = startId; i <= latestId; i++) {
        applyMigration(db, migrations[i], logger);
    }
}
function applyMigration(db, migration, logger) {
    logger.info("Applying migration ".concat(migration.filename, "..."));
    db.transaction(function () {
        db.exec(migration.sql);
        db.prepare("insert into applied_migrations (id, file_name, file_hash) values (?, ?, ?);").run(migration.id, migration.filename, migration.hash);
    })();
}
//# sourceMappingURL=sqlite.js.map