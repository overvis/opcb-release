"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModbusRequestHandler = exports.createSyncConfigHandler = void 0;
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const _1 = require(".");
const modbus_1 = require("./modbus");
const virtual_params_1 = require("./virtual-params");
function createSyncConfigHandler(state) {
    return async () => {
        _1.logger.debug("Got sync config command.");
        const conf = await state.bus.getConfs(["virtualDevice:isEnabled", "virtualDevice:uid"]);
        state.configData.isEnabled = conf["virtualDevice:isEnabled"] === "true";
        state.configData.uid = Number(conf["virtualDevice:uid"]);
        await state.bus.setState({
            "virtualDevice:isEnabled": state.configData.isEnabled,
            "virtualDevice:uid": state.configData.uid,
        });
        await state.bus.writeLogStream("log:VIR", "#", Buffer.from("sync config"));
        await state.bus.sendMsg(new opcb_ts_shared_1.redisBus.Done());
    };
}
exports.createSyncConfigHandler = createSyncConfigHandler;
function createModbusRequestHandler(state, configMap, stateMap, virtParamsMap) {
    return async (cmd) => {
        _1.logger.debug("Got modbus request command.");
        await state.bus.writeLogStream("log:VIR", "RX", cmd.data);
        const modbusId = cmd.data.readUInt8(0);
        if (cmd.type !== "rtu-no-crc" ||
            state.configData.isEnabled !== true ||
            modbusId !== state.configData.uid) {
            return;
        }
        const func = cmd.data.readUInt8(1);
        let res;
        switch (func) {
            case modbus_1.ModbusFunctionCode.ReadHoldingRegisters: {
                res = await respondToReadRequest(state, cmd, configMap, stateMap, virtParamsMap);
                break;
            }
            case modbus_1.ModbusFunctionCode.ReadInputRegisters:
                res = await respondToReadRequest(state, cmd, configMap, stateMap, virtParamsMap, true);
                break;
            case modbus_1.ModbusFunctionCode.WriteSingleHolding:
                res = await respondToWriteSingleRegister(state, cmd, configMap);
                break;
            case modbus_1.ModbusFunctionCode.WriteMultipleHolding:
                res = await respondToWriteMultipleRegisters(state, cmd, configMap, virtParamsMap);
                break;
            default:
                res = (0, modbus_1.createModbusError)(func, modbus_1.ModbusExceptionCode.IllegalFunction);
        }
        const response = Buffer.concat([Buffer.from([modbusId]), res]);
        await state.bus.writeLogStream("log:VIR", "TX", response);
        return new opcb_ts_shared_1.redisBus.ModbusResponse(response, "rtu-no-crc");
    };
}
exports.createModbusRequestHandler = createModbusRequestHandler;
async function respondToReadRequest(state, cmd, configMap, stateMap, virtParamsMap, inputRegisters = false) {
    const startAddress = cmd.data.readUInt16BE(2);
    const func = inputRegisters
        ? modbus_1.ModbusFunctionCode.ReadInputRegisters
        : modbus_1.ModbusFunctionCode.ReadHoldingRegisters;
    const quantity = cmd.data.readUInt16BE(4);
    if (quantity > 125) {
        return (0, modbus_1.createModbusError)(func, modbus_1.ModbusExceptionCode.IllegalDataAddress);
    }
    if (startAddress >= 10000 && startAddress + quantity < 11000) {
        return (0, virtual_params_1.readSqliteRegisters)(state.db, startAddress, quantity);
    }
    const addresses = Array.from({ length: quantity }, (_, i) => startAddress + i);
    const stateKeys = [];
    const configKeys = [];
    const addressMapperMap = new Map();
    for (const address of addresses) {
        let param = virtParamsMap.get(address);
        if (!param) {
            param = inputRegisters ? stateMap.get(address) : configMap.get(address);
        }
        if (!param) {
            return (0, modbus_1.createModbusError)(func, modbus_1.ModbusExceptionCode.IllegalDataAddress);
        }
        addressMapperMap.set(address, param);
        if (param.source === "state") {
            stateKeys.push(param.path);
        }
        else if (param.source === "config") {
            configKeys.push(param.path);
        }
    }
    const redisValues = {
        ...(await state.bus.getState(stateKeys)),
        ...(await state.bus.getConfs(configKeys)),
    };
    const response = Buffer.alloc(2 + quantity * 2);
    response.writeUInt8(func, 0);
    response.writeUInt8(quantity * 2, 1);
    for (const [i, address] of addresses.entries()) {
        const param = addressMapperMap.get(address);
        const redisVal = redisValues[param.path];
        const addressIndex = param.mapper.getRegisterAddresses().indexOf(address);
        const modbusVal = param.mapper.toModbusValue(redisVal || null)[addressIndex];
        response.writeUint16BE(modbusVal, 2 + i * 2);
    }
    return response;
}
async function respondToWriteSingleRegister(state, cmd, paramsMap) {
    const address = cmd.data.readUint16BE(2);
    if (address >= 10000 && address < 11000) {
        return (0, virtual_params_1.writeSqliteRegisters)(state.db, address, [cmd.data.readUInt16BE(4)], modbus_1.ModbusFunctionCode.WriteSingleHolding);
    }
    const param = paramsMap.get(address);
    if (!param) {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteSingleHolding, modbus_1.ModbusExceptionCode.IllegalDataAddress);
    }
    // read current value from redis
    const redisValue = (await state.bus.getConfs([param.path]))[param.path];
    // convert it to modbus value
    const redisModbasValue = param.mapper.toModbusValue(redisValue || null);
    // read new value from request
    const modbusValue = new Uint16Array([cmd.data.readUint16BE(4)]);
    // replace value for current address
    const index = param.mapper.getRegisterAddresses().indexOf(address);
    redisModbasValue[index] = modbusValue[0];
    let value;
    try {
        value = param.mapper.fromModbusValue(redisModbasValue);
    }
    catch (e) {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteSingleHolding, modbus_1.ModbusExceptionCode.IllegalDataValue);
    }
    const validationResp = await state.bus.sendRequest(new opcb_ts_shared_1.redisBus.SetConfig({ [param.path]: value }));
    if (validationResp.status !== "ok") {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteSingleHolding, modbus_1.ModbusExceptionCode.IllegalDataValue);
    }
    const response = Buffer.alloc(5);
    response.writeUInt8(modbus_1.ModbusFunctionCode.WriteSingleHolding, 0);
    response.writeUInt16BE(address, 1);
    response.writeUInt16BE(cmd.data.readUint16BE(4), 3);
    return response;
}
async function respondToWriteMultipleRegisters(state, cmd, paramsMap, virtParamsMap) {
    const startAddress = cmd.data.readUint16BE(2);
    const quantity = cmd.data.readUint16BE(4);
    if (quantity > 125) {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataAddress);
    }
    if (startAddress >= 10000 && startAddress + quantity < 11000) {
        const values = Array.from({ length: quantity }, (_, i) => cmd.data.readUInt16BE(7 + i * 2));
        return (0, virtual_params_1.writeSqliteRegisters)(state.db, startAddress, values, modbus_1.ModbusFunctionCode.WriteMultipleHolding);
    }
    // write activation code
    if (startAddress === 109) {
        const param = virtParamsMap.get(109);
        if (!param) {
            return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataAddress);
        }
        return await (0, virtual_params_1.writeActivationCode)(state.bus, cmd.data, param);
    }
    const modbusAddressValMap = new Map();
    const keys = [];
    const paramPathMapperMap = new Map();
    for (let i = 0; i < quantity; i++) {
        // fill map
        const address = startAddress + i;
        modbusAddressValMap.set(address, cmd.data.readUint16BE(7 + i * 2));
        const param = paramsMap.get(address);
        if (!param) {
            return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataAddress);
        }
        // fill keys for redis
        keys.push(param.path);
        // fill map<path, mapper>
        paramPathMapperMap.set(param.path, param.mapper);
    }
    // get values from redis
    const redisValues = await state.bus.getConfs(keys);
    // convert redis values to modbus values
    const redisModbusValues = {};
    for (const [path, redisValue] of Object.entries(redisValues)) {
        const mapper = paramPathMapperMap.get(path);
        if (!mapper) {
            throw new Error(`Param mapper not found for path ${path}`);
        }
        const modbusValues = mapper.toModbusValue(redisValue || null);
        for (const [i, address] of mapper.getRegisterAddresses().entries()) {
            redisModbusValues[address] = modbusValues[i];
        }
    }
    // replace values from redis with values from request
    for (const [address, modbusVal] of modbusAddressValMap) {
        redisModbusValues[address] = modbusVal;
    }
    // convert modbus values to redis values
    const values = {};
    for (const [path, mapper] of paramPathMapperMap) {
        const addresses = mapper.getRegisterAddresses();
        const modbusValues = new Uint16Array(addresses.length);
        for (const [i, address] of addresses.entries()) {
            modbusValues[i] = redisModbusValues[address];
        }
        try {
            values[path] = mapper.fromModbusValue(modbusValues);
        }
        catch (e) {
            return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataValue);
        }
    }
    const validationResp = await state.bus.sendRequest(new opcb_ts_shared_1.redisBus.SetConfig(values));
    if (validationResp.status !== "ok") {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataValue);
    }
    const response = Buffer.alloc(5);
    response.writeUint8(modbus_1.ModbusFunctionCode.WriteMultipleHolding, 0);
    response.writeUInt16BE(cmd.data.readUint16BE(2), 1);
    response.writeUInt16BE(cmd.data.readUint16BE(4), 3);
    return response;
}
//# sourceMappingURL=handlers.js.map