"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModbusUserParameters = exports.createModbusParameters = exports.createAddressParamMap = void 0;
const USER_FREE_PARAMS_QUANTITY = 200;
function createAddressParamMap(schema, map, source, prevKey, prevAddressSpacing) {
    const properties = (schema.items ? schema.items.properties : schema.properties);
    if (schema.items) {
        if (!schema.modbusArrayAddressSpacing) {
            return map;
        }
        const maxItems = schema.maxItems;
        const addressSpacing = schema.modbusArrayAddressSpacing;
        for (const [key, value] of Object.entries(properties)) {
            const subSchema = value;
            for (let i = 0; i < maxItems; i++) {
                const path = prevKey ? `${prevKey}:${i}:${key}` : `${key}${i}`;
                if (subSchema.properties || subSchema.items) {
                    createAddressParamMap(subSchema, map, source, path, addressSpacing * i);
                }
                else if (subSchema.mapper) {
                    const addresses = subSchema.mapper.getRegisterAddresses();
                    const mapper = subSchema.mapper.shiftAddress(addressSpacing * i);
                    for (const address of addresses) {
                        const addressNum = address + i * addressSpacing;
                        map.set(addressNum, {
                            path,
                            mapper,
                            source: subSchema.source || source || null,
                        });
                    }
                }
            }
        }
    }
    else if (schema.properties) {
        for (const [key, value] of Object.entries(properties)) {
            const subSchema = value;
            const path = subSchema.path ? subSchema.path : prevKey ? `${prevKey}:${key}` : key;
            if (subSchema.properties || subSchema.items) {
                createAddressParamMap(subSchema, map, source, path);
            }
            else if (subSchema.mapper) {
                let addresses = subSchema.mapper.getRegisterAddresses();
                let mapper = subSchema.mapper;
                if (prevAddressSpacing) {
                    mapper = subSchema.mapper.shiftAddress(prevAddressSpacing);
                    addresses = addresses.map((address) => address + prevAddressSpacing);
                }
                for (const address of addresses) {
                    map.set(address, {
                        path,
                        mapper,
                        source: subSchema.source || source || null,
                    });
                }
            }
        }
    }
    return map;
}
exports.createAddressParamMap = createAddressParamMap;
function createModbusParameters(schema, source, state, prevKey, prevAddressSpacing) {
    const properties = (schema.items ? schema.items.properties : schema.properties);
    if (schema.items) {
        if (!schema.modbusArrayAddressSpacing) {
            return state;
        }
        const maxItems = schema.maxItems;
        const addressSpacing = schema.modbusArrayAddressSpacing;
        for (const [key, value] of Object.entries(properties)) {
            const subSchema = value;
            for (let i = 0; i < maxItems; i++) {
                const path = prevKey ? `${prevKey}:${i}:${key}` : `${key}${i}`;
                if (subSchema.properties || subSchema.items) {
                    createModbusParameters(subSchema, source, state, path, i * addressSpacing);
                }
                else if (subSchema.mapper) {
                    const registers = subSchema.mapper
                        .getRegisterAddresses()
                        .map((a) => a + i * addressSpacing);
                    const paramSource = subSchema.source || source;
                    const type = paramSource === "state" ? "input" : "holding";
                    state.push({
                        name: `${subSchema.name} ${i + 1}`,
                        registers,
                        description: subSchema.description,
                        type: subSchema.regType || type,
                        group: subSchema.group,
                        redisPath: path,
                        source: paramSource,
                        units: subSchema.units,
                        multiplier: subSchema.multiplier,
                    });
                }
            }
        }
    }
    else if (schema.properties) {
        for (const [key, value] of Object.entries(properties)) {
            const subSchema = value;
            const path = subSchema.path ? subSchema.path : prevKey ? `${prevKey}:${key}` : key;
            if (subSchema.properties || subSchema.items) {
                createModbusParameters(subSchema, source, state, path);
            }
            else if (subSchema.mapper) {
                const paramSource = subSchema.source || source;
                const type = paramSource === "state" ? "input" : "holding";
                let mapper = subSchema.mapper;
                if (prevAddressSpacing) {
                    mapper = subSchema.mapper.shiftAddress(prevAddressSpacing);
                }
                state.push({
                    name: subSchema.name,
                    registers: mapper.getRegisterAddresses(),
                    description: subSchema.description,
                    type: subSchema.regType || type,
                    group: subSchema.group,
                    redisPath: path,
                    source: paramSource,
                    units: subSchema.units,
                    multiplier: subSchema.multiplier,
                });
            }
        }
    }
    return state;
}
exports.createModbusParameters = createModbusParameters;
function createModbusUserParameters() {
    const result = [];
    for (let i = 0; i < USER_FREE_PARAMS_QUANTITY; i++) {
        result.push({
            name: `Register of user saved values ${i}`,
            registers: [10000 + i],
            description: `Register of user saved values ${i}`,
            type: "holding",
            group: "User saved values",
            hiddenDescription: true,
            source: "modbus",
            redisPath: `${10000 + i}`,
        });
    }
    return result;
}
exports.createModbusUserParameters = createModbusUserParameters;
//# sourceMappingURL=parameter.js.map