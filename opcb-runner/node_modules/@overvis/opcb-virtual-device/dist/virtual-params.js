"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeSqliteRegisters = exports.readSqliteRegisters = exports.writeActivationCode = exports.VIRTUAL_PARMAS_SCHEMA = void 0;
const opcb_ts_shared_1 = require("@overvis/opcb-ts-shared");
const typebox_1 = require("@sinclair/typebox");
const modbus_1 = require("./modbus");
exports.VIRTUAL_PARMAS_SCHEMA = typebox_1.Type.Object({
    deviceType: typebox_1.Type.Integer({
        name: "Code identifying the MODBUS product",
        regType: "holding",
        mapper: new opcb_ts_shared_1.MAPPERS.U16Literal(0, "42"),
        description: "Code identifying the MODBUS product.",
        group: "General state",
        source: "modbus",
        path: "0",
    }),
    firmwareVersion: typebox_1.Type.Integer({
        name: "Firmware version",
        source: "state",
        regType: "holding",
        path: "release:versionNum",
        mapper: new opcb_ts_shared_1.MAPPERS.U8(1),
        description: "Firmware version.",
        group: "General state",
    }),
    uniqueMacAddress: typebox_1.Type.String({
        name: "Unique MAC address",
        source: "state",
        regType: "holding",
        path: "overvisRc:mac",
        mapper: new opcb_ts_shared_1.MAPPERS.Mac(102),
        description: "Unique MAC address of the device.",
        group: "General state",
    }),
    state: typebox_1.Type.Integer({
        name: "State of the device",
        regType: "holding",
        mapper: new opcb_ts_shared_1.MAPPERS.U16(108),
        description: "State of the device.",
        group: "General state",
    }),
    activationCode: typebox_1.Type.Integer({
        name: "Activation code",
        source: "state",
        regType: "holding",
        path: "overvisRc:activationCode",
        mapper: new opcb_ts_shared_1.MAPPERS.U32(109),
        description: "Activation code of the device.",
        group: "General state",
    }),
});
async function writeActivationCode(bus, data, param) {
    if (data.readUInt16BE(4) < 2) {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataValue);
    }
    const acCode = (data.readUInt16BE(7) << 16) + data.readUInt16BE(9);
    if (acCode < 10000000 || acCode > 99999999) {
        return (0, modbus_1.createModbusError)(modbus_1.ModbusFunctionCode.WriteMultipleHolding, modbus_1.ModbusExceptionCode.IllegalDataValue);
    }
    await bus.setState({ [param.path]: acCode.toFixed(0) });
    const response = Buffer.alloc(5);
    response.writeUint8(modbus_1.ModbusFunctionCode.WriteMultipleHolding, 0);
    response.writeUInt16BE(data.readUint16BE(2), 1);
    response.writeUInt16BE(data.readUint16BE(4), 3);
    return response;
}
exports.writeActivationCode = writeActivationCode;
function readSqliteRegisters(db, startAddress, quantity) {
    const res = db
        .prepare(`select * from stored_registers where address >= ? and address < ? order by address;`)
        .all(startAddress, startAddress + quantity);
    const resultMap = res.reduce((acc, r) => {
        acc[r.address] = r.value;
        return acc;
    }, {});
    const response = Buffer.alloc(2 + quantity * 2);
    response.writeUInt8(modbus_1.ModbusFunctionCode.ReadHoldingRegisters, 0);
    response.writeUInt8(quantity * 2, 1);
    for (let i = 0; i < quantity; i++) {
        const value = resultMap[startAddress + i] || 0;
        value && response.writeUint16BE(value, 2 + i * 2);
    }
    return response;
}
exports.readSqliteRegisters = readSqliteRegisters;
function writeSqliteRegisters(db, address, values, functionCode) {
    const addressesValuesList = values.map((v, i) => `(${address + i}, ${v})`).join(", ");
    db.prepare(`insert into stored_registers (address, value) values ${addressesValuesList} ` +
        `on conflict(address) do update set value = excluded.value;`).run();
    const response = Buffer.alloc(5);
    response.writeUint8(functionCode, 0);
    response.writeUInt16BE(address, 1);
    if (functionCode === modbus_1.ModbusFunctionCode.WriteSingleHolding) {
        response.writeUInt16BE(values[0], 3);
    }
    else {
        response.writeUInt16BE(values.length, 3);
    }
    return response;
}
exports.writeSqliteRegisters = writeSqliteRegisters;
//# sourceMappingURL=virtual-params.js.map