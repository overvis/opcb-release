"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseMonitor = exports.timeout = void 0;
async function timeout(ms, promise) {
    return new Promise((resolve, reject) => {
        let timedOut = false;
        const timer = setTimeout(() => {
            reject(new Error("timeout"));
            timedOut = true;
        }, ms);
        promise
            .then((res) => {
            if (timedOut) {
                return res;
            }
            clearTimeout(timer);
            resolve(res);
            return res;
        })
            .catch((err) => {
            if (timedOut) {
                return;
            }
            clearTimeout(timer);
            reject(err);
        });
    });
}
exports.timeout = timeout;
class PromiseMonitor {
    constructor(prm) {
        this._status = "pending";
        this._isPending = true;
        this._isResolved = false;
        this._isRejected = false;
        // eslint-disable-next-line promise/catch-or-return
        prm.then((result) => {
            this._status = "resolved";
            this._isResolved = true;
            this._isPending = false;
            this._result = result;
            return result;
        }, (err) => {
            this._status = "rejected";
            this._isPending = false;
            this._isRejected = true;
            this._error = err instanceof Error ? err : new Error("unknown error");
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return err;
        });
    }
    get status() {
        return this._status;
    }
    get isPending() {
        return this._isPending;
    }
    get isResolved() {
        return this._isResolved;
    }
    get isRejected() {
        return this._isRejected;
    }
    get error() {
        return this._error;
    }
    get result() {
        return this._result;
    }
}
exports.PromiseMonitor = PromiseMonitor;
//# sourceMappingURL=promises.js.map